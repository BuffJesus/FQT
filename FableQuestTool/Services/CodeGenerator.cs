using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using FableQuestTool.Data;
using FableQuestTool.Models;

namespace FableQuestTool.Services;

public sealed class CodeGenerator
{
    // Set of node types that are cinematic/async and need pauses after them
    private static readonly HashSet<string> CinematicNodeTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "letterbox", "letterboxOff", "screenFadeOut", "screenFadeIn", "overrideMusic", 
        "stopMusicOverride", "cameraOrbitEntity", "cameraLookAtEntity", "cameraResetToHero",
        "cameraUseCameraPoint", "cameraConversation", "cameraCircleAroundThing",
        "startConversation", "addConversationLine", "endConversation",
        "radialBlur", "radialBlurOff", "colorFilter", "colorFilterOff",
        "playMovie", "startMovieSequence", "endMovieSequence"
    };

    public string GenerateQuestScript(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {quest.Name}.lua");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("Quest = nil");
        sb.AppendLine();

        // Generate Init function
        GenerateInitFunction(sb, quest);

        // Generate Main function
        GenerateMainFunction(sb, quest);

        // Generate OnPersist function
        GenerateOnPersistFunction(sb, quest);

        // Generate EntitySpawner thread if needed
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) || 
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            GenerateEntitySpawnerThread(sb, quest);
        }

        // Generate MonitorQuestCompletion thread
        GenerateMonitorQuestCompletion(sb, quest);

        // Generate user-defined threads
        foreach (QuestThread thread in quest.Threads)
        {
            GenerateUserThread(sb, thread);
        }

        // Generate reward object interaction thread if needed (for generic object mode with manual opening)
        if (quest.Rewards.Container != null &&
            quest.Rewards.Container.UseGenericObjectMode &&
            !quest.Rewards.Container.AutoGiveOnComplete)
        {
            GenerateRewardObjectInteractionThread(sb, quest);
        }

        // CompleteQuest logic is now inlined in MonitorQuestCompletion thread to preserve thread context

        return sb.ToString();
    }

    public string GenerateEntityScript(QuestProject quest, QuestEntity entity)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {entity.ScriptName}.lua");
        sb.AppendLine($"-- Entity script for {quest.Name}");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("local Quest = nil");
        sb.AppendLine("local Me = nil");
        sb.AppendLine();
        sb.AppendLine("function Init(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Init called\")");

        // Entity control settings
        if (entity.MakeBehavioral)
        {
            sb.AppendLine("    Me:MakeBehavioral()");
        }
        // Always use AcquireControl if enabled, as it works with SpeakAndWait
        // TakeExclusiveControl does NOT work with SpeakAndWait
        if (entity.AcquireControl)
        {
            sb.AppendLine("    Me:AcquireControl()");
        }
        else if (entity.ExclusiveControl)
        {
            sb.AppendLine("    Me:TakeExclusiveControl()");
        }

        sb.AppendLine("end");
        sb.AppendLine();
        sb.AppendLine("function Main(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Main started\")");
        sb.AppendLine("    local hero = Quest:GetHero()");

        // Entity properties
        if (entity.Invulnerable)
        {
            sb.AppendLine("    Quest:EntitySetAsDamageable(Me, false)");
        }
        if (entity.Unkillable)
        {
            sb.AppendLine("    Quest:EntitySetAsKillable(Me, false)");
        }
        if (entity.Persistent)
        {
            sb.AppendLine("    Quest:SetThingPersistent(Me, true)");
        }
        if (entity.KillOnLevelUnload)
        {
            sb.AppendLine("    Me:SetToKillOnLevelUnload(true)");
        }

        sb.AppendLine();

        // Check if this object entity has rewards configured
        bool hasObjectRewards = entity.EntityType == EntityType.Object &&
                               entity.ObjectReward != null &&
                               entity.ObjectReward.HasRewards;

        if (entity.Nodes.Count > 0)
        {
            sb.AppendLine("    -- Main behavior loop");
            sb.AppendLine("    while true do");

            // Generate code from node graph
            string behaviorCode = GenerateBehaviorCode(entity, quest.Name, 2);
            sb.Append(behaviorCode);

            sb.AppendLine();
            sb.AppendLine("        if Me:IsNull() then break end");
            // Frame check at END of loop only (like working MAssassinNPC example)
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }
        else if (hasObjectRewards)
        {
            // Object has rewards but no custom behavior nodes - auto-generate reward behavior
            GenerateObjectRewardBehavior(sb, entity);
        }
        else if (entity.AcquireControl || entity.ExclusiveControl)
        {
            // Entity has control but no behavior nodes - add minimal loop
            sb.AppendLine("    -- Minimal behavior loop (add behavior nodes for triggers and actions)");
            sb.AppendLine("    while true do");
            sb.AppendLine("        -- Add trigger nodes in the visual editor to respond to hero interactions");
            sb.AppendLine("        if Me:IsNull() then break end");
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }

        sb.AppendLine();
        sb.AppendLine("    Me:ReleaseControl()");
        sb.AppendLine("end");

        return sb.ToString();
    }

    public string GenerateRegistrationSnippet(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("-- Add this entry inside the Quests table in quests.lua");
        sb.Append(GenerateQuestLuaEntry(quest));
        return sb.ToString();
    }

    private void GenerateInitFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Init(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Init phase started.\")");

        // Add quest regions
        foreach (string region in quest.Regions)
        {
            sb.AppendLine($"    Quest:AddQuestRegion(\"{quest.Name}\", \"{region}\")");
        }

        // Set world map offset
        var mapOffset = GetWorldMapOffset(quest);
        sb.AppendLine($"    Quest:SetQuestWorldMapOffset(\"{quest.Name}\", {mapOffset.X}, {mapOffset.Y})");

        // Initialize QuestCompleted state
        sb.AppendLine("    Quest:SetStateBool(\"QuestCompleted\", false)");

        // Initialize user-defined states
        foreach (QuestState state in quest.States)
        {
            sb.AppendLine(RenderStateInit(state));
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateMainFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Main(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Main() started.\")");
        sb.AppendLine();

        // Bind entity scripts
        if (quest.Entities.Count > 0)
        {
            sb.AppendLine("    -- Bind entity scripts");
            foreach (QuestEntity entity in quest.Entities)
            {
                sb.AppendLine($"    Quest:AddEntityBinding(\"{entity.ScriptName}\", \"{quest.Name}/Entities/{entity.ScriptName}\")");
            }
            sb.AppendLine("    Quest:FinalizeEntityBindings()");
            sb.AppendLine();
        }

        // Quest card configuration
        if (!string.IsNullOrWhiteSpace(quest.QuestCardObject))
        {
            sb.AppendLine("    -- Configure quest card");
            if (quest.IsGuildQuest)
            {
                sb.AppendLine($"    Quest:AddGuildQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }
            else if (quest.GiveCardDirectly)
            {
                sb.AppendLine($"    Quest:GiveQuestCardDirectly(\"{quest.QuestCardObject}\", \"{quest.Name}\", true)");
            }
            else
            {
                sb.AppendLine($"    Quest:AddQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }

            if (!string.IsNullOrWhiteSpace(quest.ObjectiveText))
            {
                string region1 = quest.ObjectiveRegion1 ?? quest.Regions.FirstOrDefault() ?? "";
                string region2 = quest.ObjectiveRegion2 ?? "";
                sb.AppendLine($"    Quest:SetQuestCardObjective(\"{quest.Name}\", \"{Escape(quest.ObjectiveText)}\", \"{region1}\", \"{region2}\")");
            }

            if (quest.Rewards.Gold > 0)
            {
                sb.AppendLine($"    Quest:SetQuestGoldReward(\"{quest.Name}\", {quest.Rewards.Gold})");
            }

            if (quest.Rewards.Renown > 0)
            {
                sb.AppendLine($"    Quest:SetQuestRenownReward(\"{quest.Name}\", {quest.Rewards.Renown})");
            }
            sb.AppendLine();
        }

        // Show quest start screen
        if (quest.UseQuestStartScreen)
        {
            string isStory = quest.IsStoryQuest ? "true" : "false";
            string isGold = quest.IsGoldQuest ? "true" : "false";
            sb.AppendLine("    -- Show quest start screen");
            sb.AppendLine($"    Quest:KickOffQuestStartScreen(\"{quest.Name}\", {isStory}, {isGold})");
            sb.AppendLine();
        }

        // Start threads
        sb.AppendLine("    -- Start quest threads");
        
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";
        
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) ||
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            sb.AppendLine($"    Quest:CreateThread(\"EntitySpawner\", {{region=\"{primaryRegion}\"}})");
        }

        sb.AppendLine($"    Quest:CreateThread(\"MonitorQuestCompletion\", {{region=\"{primaryRegion}\"}})");

        foreach (QuestThread thread in quest.Threads)
        {
            sb.AppendLine($"    Quest:CreateThread(\"{thread.FunctionName}\", {{region=\"{thread.Region}\"}})");
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateOnPersistFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function OnPersist(questObject, context)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Quest:PersistTransferBool(context, \"QuestCompleted\")");

        foreach (QuestState state in quest.States)
        {
            if (state.Persist)
            {
                sb.AppendLine(RenderStatePersist(state));
            }
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateEntitySpawnerThread(StringBuilder sb, QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";

        sb.AppendLine("function EntitySpawner(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    -- Thread is region-bound to {primaryRegion} - FSE auto-waits for region load");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner executing (region is loaded).\")");
        sb.AppendLine();
        sb.AppendLine("    -- Brief pause to let game settle after region load");
        sb.AppendLine("    Quest:Pause(0.5)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
        sb.AppendLine();

        // Spawn entities
        var entitiesToSpawn = quest.Entities.Where(e => e.SpawnMethod != SpawnMethod.BindExisting).ToList();
        if (entitiesToSpawn.Count > 0)
        {
            sb.AppendLine("    -- Spawn entities");
            foreach (QuestEntity entity in entitiesToSpawn)
            {
                string spawnCode = GenerateEntitySpawnCode(entity);
                if (!string.IsNullOrWhiteSpace(spawnCode))
                {
                    sb.AppendLine(spawnCode);
                    sb.AppendLine();
                }
            }
        }

        // Set up quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("    -- Set up quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"    local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"    if {entity.ScriptName} ~= nil then");
                
                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"        Quest:SetThingHasInformation({entity.ScriptName}, true)");
                }
                
                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"        Quest:MiniMapAddMarker({entity.ScriptName}, \"{entity.ScriptName}\")");
                }
                
                sb.AppendLine("    end");
            }
            sb.AppendLine();
        }

        // Note: Container rewards are now spawned during quest completion, not here
        // This prevents issues with containers despawning before quest completes

        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner completed.\")");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private string GenerateEntitySpawnCode(QuestEntity entity)
    {
        // Use CreateObject for Object entities, CreateCreature for others
        if (entity.EntityType == EntityType.Object)
        {
            return entity.SpawnMethod switch
            {
                SpawnMethod.AtMarker => GenerateCreateObjectAtMarker(entity),
                SpawnMethod.AtPosition => GenerateCreateObjectAtPosition(entity),
                SpawnMethod.CreateCreature => GenerateCreateObjectAtMarker(entity),
                SpawnMethod.OnEntity => GenerateCreateObjectOnEntity(entity),
                _ => string.Empty
            };
        }

        return entity.SpawnMethod switch
        {
            SpawnMethod.AtMarker => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.AtPosition => GenerateCreateCreatureAtPosition(entity),
            SpawnMethod.CreateCreature => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.OnEntity => GenerateCreateCreatureOnEntity(entity),
            _ => string.Empty
        };
    }

    private string GenerateCreateCreatureAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local {entity.ScriptName} = Quest:CreateCreatureOnEntity(""{entity.DefName}"", targetEntity_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = targetEntity_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private void GenerateMonitorQuestCompletion(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function MonitorQuestCompletion(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Quest:GetStateBool(\"QuestCompleted\") then");
        sb.AppendLine($"            Quest:Log(\"{quest.Name}: Quest completed, giving rewards...\")");
        sb.AppendLine();

        // Clear quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("            -- Clear quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"            local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"            if {entity.ScriptName} ~= nil then");

                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"                Quest:ClearThingHasInformation({entity.ScriptName})");
                }

                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"                Quest:MiniMapRemoveMarker({entity.ScriptName})");
                }

                sb.AppendLine("            end");
            }
            sb.AppendLine();
        }

        // Give rewards
        sb.AppendLine("            -- Give rewards");
        if (quest.Rewards.Gold > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroGold(\"{quest.Rewards.Gold}\", 1)");
        }
        if (quest.Rewards.Experience > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroExperience({quest.Rewards.Experience})");
        }
        if (quest.Rewards.Renown > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroRenownPoints({quest.Rewards.Renown})");
        }
        if (quest.Rewards.Morality != 0)
        {
            sb.AppendLine($"            Quest:GiveHeroMorality({quest.Rewards.Morality})");
        }

        // Single direct reward item (limited by game engine)
        if (!string.IsNullOrWhiteSpace(quest.Rewards.DirectRewardItem))
        {
            sb.AppendLine($"            Quest:GiveHeroObject(\"{quest.Rewards.DirectRewardItem}\", 1)");
        }

        // Container-based rewards (for multiple items)
        if (quest.Rewards.Container != null && quest.Rewards.Container.Items.Count > 0)
        {
            GenerateContainerReward(sb, quest);
        }

        sb.AppendLine();
        sb.AppendLine("            -- Complete and deactivate quest");
        sb.AppendLine($"            Quest:SetQuestAsCompleted(\"{quest.Name}\", true, false, false)");
        sb.AppendLine($"            Quest:DeactivateQuestLater(\"{quest.Name}\", 0)");
        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine("        Quest:Pause(0.5)");
        sb.AppendLine("        if not Quest:NewScriptFrame() then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateUserThread(StringBuilder sb, QuestThread thread)
    {
        sb.AppendLine($"function {thread.FunctionName}(questObject)");
        sb.AppendLine("    Quest = questObject");
        if (!string.IsNullOrWhiteSpace(thread.Description))
        {
            sb.AppendLine($"    -- {thread.Description}");
        }
        sb.AppendLine("    -- TODO: Implement thread logic");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    // GenerateCompleteQuestFunction has been removed - completion logic is now inlined
    // in MonitorQuestCompletion thread to preserve PActiveThread context

    private void GenerateContainerSpawn(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine();
        sb.AppendLine("    -- Spawn reward container");

        // Generate spawn code based on location type
        switch (container.SpawnLocation)
        {
            case ContainerSpawnLocation.NearMarker:
                sb.AppendLine($"    local marker = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine("    local containerPos");
                sb.AppendLine("    if marker ~= nil then");
                sb.AppendLine("        containerPos = marker:GetPos()");
                sb.AppendLine("    else");
                sb.AppendLine("        local hero = Quest:GetHero()");
                sb.AppendLine("        containerPos = hero:GetPos()");
                sb.AppendLine("    end");
                break;

            case ContainerSpawnLocation.NearEntity:
                sb.AppendLine($"    local entity = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine("    local containerPos");
                sb.AppendLine("    if entity ~= nil then");
                sb.AppendLine("        containerPos = entity:GetPos()");
                sb.AppendLine("    else");
                sb.AppendLine("        local hero = Quest:GetHero()");
                sb.AppendLine("        containerPos = hero:GetPos()");
                sb.AppendLine("    end");
                break;

            case ContainerSpawnLocation.FixedPosition:
                string x = container.X.ToString(CultureInfo.InvariantCulture);
                string y = container.Y.ToString(CultureInfo.InvariantCulture);
                string z = container.Z.ToString(CultureInfo.InvariantCulture);
                sb.AppendLine($"    local containerPos = {{x={x}, y={y}, z={z}}}");
                break;
        }

        sb.AppendLine($"    local container = Quest:CreateObject(\"{container.ContainerDefName}\", containerPos, \"{container.ContainerScriptName}\")");
        sb.AppendLine("    if container ~= nil then");

        // Add items to container
        foreach (string item in container.Items)
        {
            sb.AppendLine($"        Quest:AddItemToContainer(container, \"{item}\")");
        }

        // Highlight container if configured
        if (container.HighlightContainer)
        {
            sb.AppendLine("        Quest:SetThingHasInformation(container, true)");
        }

        sb.AppendLine("    end");
        sb.AppendLine("    Quest:Pause(0.1)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
    }

    private void GenerateContainerReward(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        // Use generic object mode or traditional container mode
        if (container.UseGenericObjectMode)
        {
            GenerateGenericObjectReward(sb, quest);
        }
        else
        {
            GenerateTraditionalContainerReward(sb, quest);
        }
    }

    /// <summary>
    /// Generates traditional container-based rewards using container APIs.
    /// Only works with chest-like objects.
    /// </summary>
    private void GenerateTraditionalContainerReward(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine();
        sb.AppendLine("            -- Container reward: Spawn and populate container");
        sb.AppendLine("            Quest:Log(\"Attempting to spawn container...\")");

        // Generate spawn position code
        GenerateContainerSpawnPosition(sb, container, "            ");

        // Spawn the container
        sb.AppendLine($"            Quest:Log(\"Creating container: {container.ContainerDefName} at position...\")");
        sb.AppendLine($"            local container = Quest:CreateObject(\"{container.ContainerDefName}\", containerPos, \"{container.ContainerScriptName}\")");
        sb.AppendLine("            Quest:Log(\"CreateObject returned: \" .. tostring(container))");
        sb.AppendLine("            if container ~= nil then");
        sb.AppendLine("                Quest:Log(\"Container spawned successfully!\")");

        // CRITICAL: Make the container targetable/interactive
        sb.AppendLine("                Quest:EntitySetTargetable(container, true)");
        sb.AppendLine("                Quest:Log(\"Container set as targetable\")");

        // Add items to container
        foreach (string item in container.Items)
        {
            sb.AppendLine($"                Quest:AddItemToContainer(container, \"{item}\")");
        }

        if (container.AutoGiveOnComplete)
        {
            // Automatically give all items from container
            sb.AppendLine("                Quest:GiveHeroItemsFromContainer(container, true) -- true = show UI");
        }
        else
        {
            // Just highlight the container for player to open manually
            if (container.HighlightContainer)
            {
                sb.AppendLine("                Quest:SetThingHasInformation(container, true)");
            }
        }

        sb.AppendLine("            else");
        sb.AppendLine("                Quest:Log(\"WARNING: Failed to spawn container!\")");
        sb.AppendLine("            end");
    }

    /// <summary>
    /// Generates generic object rewards that work with any OBJECT_ type.
    /// Items are given directly when the hero interacts with the object.
    /// </summary>
    private void GenerateGenericObjectReward(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine();
        sb.AppendLine("            -- Generic object reward: Spawn object and give rewards on interaction");
        sb.AppendLine("            Quest:Log(\"Spawning reward object...\")");

        // Generate spawn position code
        GenerateContainerSpawnPosition(sb, container, "            ");

        // Spawn the object
        sb.AppendLine($"            Quest:Log(\"Creating object: {container.ContainerDefName} at position...\")");
        sb.AppendLine($"            local rewardObject = Quest:CreateObject(\"{container.ContainerDefName}\", containerPos, \"{container.ContainerScriptName}\")");
        sb.AppendLine("            if rewardObject ~= nil then");
        sb.AppendLine("                Quest:Log(\"Reward object spawned successfully!\")");

        // Make interactive
        sb.AppendLine("                Quest:EntitySetTargetable(rewardObject, true)");
        if (container.HighlightContainer)
        {
            sb.AppendLine("                Quest:SetThingHasInformation(rewardObject, true)");
        }

        if (container.AutoGiveOnComplete)
        {
            // Auto-give: Give rewards immediately
            sb.AppendLine();
            sb.AppendLine("                -- Auto-give rewards immediately");
            GenerateGenericRewardGiving(sb, container, "                ");

            if (container.DestroyAfterReward)
            {
                sb.AppendLine("                Quest:SetThingAsKilled(rewardObject)");
            }
        }
        else
        {
            // Manual: Start a thread to wait for interaction
            sb.AppendLine();
            sb.AppendLine("                -- Store object reference for interaction thread");
            sb.AppendLine($"                Quest:SetStateString(\"RewardObjectScript\", \"{container.ContainerScriptName}\")");
            sb.AppendLine($"                Quest:CreateThread(\"WaitForRewardObjectInteraction\", {{region=\"{quest.Regions.FirstOrDefault() ?? "Oakvale"}\" }})");
        }

        sb.AppendLine("            else");
        sb.AppendLine("                Quest:Log(\"WARNING: Failed to spawn reward object!\")");
        sb.AppendLine("            end");
    }

    /// <summary>
    /// Generates the spawn position code for containers/objects
    /// </summary>
    private void GenerateContainerSpawnPosition(StringBuilder sb, ContainerReward container, string indent)
    {
        switch (container.SpawnLocation)
        {
            case ContainerSpawnLocation.NearMarker:
                sb.AppendLine($"{indent}local marker = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine($"{indent}local containerPos");
                sb.AppendLine($"{indent}if marker ~= nil then");
                sb.AppendLine($"{indent}    containerPos = marker:GetPos()");
                sb.AppendLine($"{indent}else");
                sb.AppendLine($"{indent}    local hero = Quest:GetHero()");
                sb.AppendLine($"{indent}    containerPos = hero:GetPos()");
                sb.AppendLine($"{indent}end");
                break;

            case ContainerSpawnLocation.NearEntity:
                sb.AppendLine($"{indent}local entity = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine($"{indent}local containerPos");
                sb.AppendLine($"{indent}if entity ~= nil then");
                sb.AppendLine($"{indent}    containerPos = entity:GetPos()");
                sb.AppendLine($"{indent}else");
                sb.AppendLine($"{indent}    local hero = Quest:GetHero()");
                sb.AppendLine($"{indent}    containerPos = hero:GetPos()");
                sb.AppendLine($"{indent}end");
                break;

            case ContainerSpawnLocation.FixedPosition:
                string x = container.X.ToString(CultureInfo.InvariantCulture);
                string y = container.Y.ToString(CultureInfo.InvariantCulture);
                string z = container.Z.ToString(CultureInfo.InvariantCulture);
                sb.AppendLine($"{indent}local containerPos = {{x={x}, y={y}, z={z}}}");
                break;
        }
    }

    /// <summary>
    /// Generates the reward giving code for generic object mode
    /// </summary>
    private void GenerateGenericRewardGiving(StringBuilder sb, ContainerReward container, string indent)
    {
        // Give gold
        if (container.Gold > 0)
        {
            sb.AppendLine($"{indent}Quest:GiveHeroGold(\"{container.Gold}\", 1)");
        }

        // Give experience
        if (container.Experience > 0)
        {
            sb.AppendLine($"{indent}Quest:GiveHeroExperience({container.Experience})");
        }

        // Give items
        foreach (string item in container.Items)
        {
            sb.AppendLine($"{indent}Quest:GiveHeroObject(\"{item}\", 1)");
        }

        // Show message
        if (container.ShowRewardMessage)
        {
            if (!string.IsNullOrWhiteSpace(container.CustomMessage))
            {
                sb.AppendLine($"{indent}Quest:ShowMessage(\"{Escape(container.CustomMessage)}\", 3.0)");
            }
            else
            {
                // Build default message
                var messageParts = new List<string>();
                if (container.Gold > 0) messageParts.Add($"{container.Gold} gold");
                if (container.Experience > 0) messageParts.Add($"{container.Experience} XP");
                if (container.Items.Count > 0) messageParts.Add($"{container.Items.Count} item(s)");
                string defaultMessage = "Received: " + string.Join(", ", messageParts);
                sb.AppendLine($"{indent}Quest:ShowMessage(\"{defaultMessage}\", 3.0)");
            }
        }
    }

    /// <summary>
    /// Generates the thread that waits for hero interaction with the reward object
    /// </summary>
    private void GenerateRewardObjectInteractionThread(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine("function WaitForRewardObjectInteraction(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Waiting for hero to interact with reward object...\")");
        sb.AppendLine();
        sb.AppendLine("    -- Get the reward object");
        sb.AppendLine($"    local rewardObject = Quest:GetThingWithScriptName(\"{container.ContainerScriptName}\")");
        sb.AppendLine("    if rewardObject == nil then");
        sb.AppendLine($"        Quest:Log(\"{quest.Name}: ERROR - Could not find reward object!\")");
        sb.AppendLine("        return");
        sb.AppendLine("    end");
        sb.AppendLine();
        sb.AppendLine("    -- Wait for hero to interact");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if rewardObject:MsgIsUsedByHero() then");
        sb.AppendLine($"            Quest:Log(\"{quest.Name}: Hero interacted with reward object!\")");
        sb.AppendLine();

        // Generate reward giving code
        GenerateGenericRewardGiving(sb, container, "            ");

        // Destroy object if configured
        if (container.DestroyAfterReward)
        {
            sb.AppendLine();
            sb.AppendLine("            Quest:SetThingAsKilled(rewardObject)");
        }
        else if (container.HighlightContainer)
        {
            sb.AppendLine();
            sb.AppendLine("            Quest:ClearThingHasInformation(rewardObject)");
        }

        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine();
        sb.AppendLine("        if rewardObject:IsNull() then break end");
        sb.AppendLine("        if not Quest:NewScriptFrame(rewardObject) then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates automatic behavior for object entities with rewards.
    /// This creates a loop that waits for the hero to interact with the object,
    /// then gives the configured rewards.
    /// </summary>
    private void GenerateObjectRewardBehavior(StringBuilder sb, QuestEntity entity)
    {
        var reward = entity.ObjectReward!;
        string stateVar = $"{entity.ScriptName}_opened";

        sb.AppendLine("    -- Auto-generated reward behavior for object");
        sb.AppendLine("    -- This object gives rewards when interacted with by the hero");
        sb.AppendLine();

        if (reward.OneTimeOnly)
        {
            sb.AppendLine($"    local alreadyOpened = Quest:GetStateBool(\"{stateVar}\")");
            sb.AppendLine("    if alreadyOpened then");
            sb.AppendLine($"        Quest:Log(\"{entity.ScriptName}: Already opened, skipping reward behavior\")");
            sb.AppendLine("        return");
            sb.AppendLine("    end");
            sb.AppendLine();
        }

        sb.AppendLine("    -- Make object interactive");
        sb.AppendLine("    Quest:EntitySetTargetable(Me, true)");
        sb.AppendLine("    Quest:SetThingHasInformation(Me, true)");
        sb.AppendLine();
        sb.AppendLine("    -- Wait for hero interaction");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Me:MsgIsUsedByHero() then");
        sb.AppendLine($"            Quest:Log(\"{entity.ScriptName}: Hero interacted with object, giving rewards\")");
        sb.AppendLine();

        // Give gold
        if (reward.Gold > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroGold(\"{reward.Gold}\", 1)");
        }

        // Give experience
        if (reward.Experience > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroExperience({reward.Experience})");
        }

        // Give items
        foreach (string item in reward.Items)
        {
            sb.AppendLine($"            Quest:GiveHeroObject(\"{item}\", 1)");
        }

        // Show message
        if (reward.ShowMessage)
        {
            if (!string.IsNullOrWhiteSpace(reward.CustomMessage))
            {
                sb.AppendLine($"            Quest:ShowMessage(\"{Escape(reward.CustomMessage)}\", 3.0)");
            }
            else
            {
                // Build default message
                var messageParts = new List<string>();
                if (reward.Gold > 0) messageParts.Add($"{reward.Gold} gold");
                if (reward.Experience > 0) messageParts.Add($"{reward.Experience} XP");
                if (reward.Items.Count > 0) messageParts.Add($"{reward.Items.Count} item(s)");
                string defaultMessage = "Received: " + string.Join(", ", messageParts);
                sb.AppendLine($"            Quest:ShowMessage(\"{defaultMessage}\", 3.0)");
            }
        }

        // Mark as opened for one-time only objects
        if (reward.OneTimeOnly)
        {
            sb.AppendLine();
            sb.AppendLine($"            Quest:SetStateBool(\"{stateVar}\", true)");
        }

        // Destroy object if configured
        if (reward.DestroyAfterReward)
        {
            sb.AppendLine();
            sb.AppendLine("            -- Destroy the object after giving rewards");
            sb.AppendLine("            Quest:SetThingAsKilled(Me)");
            sb.AppendLine("            break");
        }
        else if (reward.OneTimeOnly)
        {
            sb.AppendLine();
            sb.AppendLine("            -- Remove highlight since object was already used");
            sb.AppendLine("            Quest:ClearThingHasInformation(Me)");
            sb.AppendLine("            break");
        }

        sb.AppendLine("        end");
        sb.AppendLine();
        sb.AppendLine("        if Me:IsNull() then break end");
        sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
        sb.AppendLine("    end");
    }

    private (int X, int Y) GetWorldMapOffset(QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "";
        return WorldMapCoordinateService.GetMapOffsetForQuest(primaryRegion, quest.Entities);
    }

    private string RenderStateInit(QuestState state)
    {
        string value = state.DefaultValue?.ToString() ?? GetDefaultForType(state.Type);
        
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:SetStateBool(\"{state.Name}\", {value.ToLowerInvariant()})",
            "int" => $"    Quest:SetStateInt(\"{state.Name}\", {value})",
            "float" => $"    Quest:SetStateFloat(\"{state.Name}\", {value})",
            "string" => $"    Quest:SetStateString(\"{state.Name}\", \"{value}\")",
            _ => $"    Quest:SetStateBool(\"{state.Name}\", false) -- Unknown type: {state.Type}"
        };
    }

    private string RenderStatePersist(QuestState state)
    {
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:PersistTransferBool(context, \"{state.Name}\")",
            "int" => $"    Quest:PersistTransferInt(context, \"{state.Name}\")",
            "float" => $"    Quest:PersistTransferFloat(context, \"{state.Name}\")",
            "string" => $"    Quest:PersistTransferString(context, \"{state.Name}\")",
            _ => $"    Quest:PersistTransferBool(context, \"{state.Name}\") -- Unknown type: {state.Type}"
        };
    }

    private string GenerateQuestLuaEntry(QuestProject quest)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    {quest.Name} = {{");
        sb.AppendLine($"        name = \"{quest.Name}\",");
        sb.AppendLine($"        file = \"{quest.Name}/{quest.Name}\",");
        sb.AppendLine($"        id = {quest.Id},");
        sb.AppendLine();
        sb.AppendLine("        entity_scripts = {");

        int entityId = quest.Id + 1;
        foreach (QuestEntity entity in quest.Entities)
        {
            sb.AppendLine($"            {{ name = \"{entity.ScriptName}\", file = \"{quest.Name}/Entities/{entity.ScriptName}\", id = {entityId} }},");
            entityId++;
        }

        sb.AppendLine("        }");
        sb.Append("    },");

        return sb.ToString();
    }

    private static string GetDefaultForType(string type)
    {
        return type.ToLowerInvariant() switch
        {
            "bool" => "false",
            "int" => "0",
            "float" => "0.0",
            "string" => "",
            _ => "false"
        };
    }

    public string GenerateBehaviorCode(QuestEntity entity, string questName, int indent = 2)
    {
        if (entity.Nodes.Count == 0)
        {
            return GenerateIndent(indent) + "-- No behavior nodes defined\n";
        }

        StringBuilder sb = new StringBuilder();

        // Find all trigger nodes (entry points)
        var triggerNodes = entity.Nodes.Where(n => n.Category == "trigger").ToList();

        if (triggerNodes.Count == 0)
        {
            sb.AppendLine(GenerateIndent(indent) + "-- No trigger nodes found");
            return sb.ToString();
        }

        // Generate code for each trigger
        foreach (var trigger in triggerNodes)
        {
            sb.Append(GenerateNodeCode(trigger, entity, questName, indent));
        }

        return sb.ToString();
    }

    private static string GenerateIndent(int level)
    {
        return new string(' ', level * 4);
    }

    /// <summary>
    /// Generates Lua code for a behavior node and its children.
    /// Handles both structured nodes (triggers, conditions) and linear action sequences.
    /// </summary>
    private string GenerateNodeCode(BehaviorNode node, QuestEntity entity, string questName, int indent)
    {
        var nodeDef = NodeDefinitions.GetAllNodes().FirstOrDefault(n => n.Type == node.Type);
        if (nodeDef == null)
        {
            return GenerateIndent(indent) + $"-- Unknown node type: {node.Type}\n";
        }

        StringBuilder sb = new StringBuilder();

        // Check if this is a linear action (non-branching action node)
        bool isLinearAction = nodeDef.Category == "action" && !nodeDef.HasBranching;

        if (isLinearAction)
        {
            // For linear actions, emit THIS node's code at current indent,
            // then emit children at SAME indent (not nested)
            string code = ProcessNodeTemplate(nodeDef, node, questName);
            
            // Remove {CHILDREN} - we handle sequencing explicitly
            code = code.Replace("{CHILDREN}", "").TrimEnd();

            // Emit this node's code lines
            foreach (string line in code.Split('\n'))
            {
                if (!string.IsNullOrWhiteSpace(line))
                {
                    sb.AppendLine(GenerateIndent(indent) + line);
                }
            }

            // Process children at SAME indent level (linear sequence, not nested)
            var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    sb.Append(GenerateNodeCode(childNode, entity, questName, indent)); // Same indent!
                }
            }
        }
        else
        {
            // For structured nodes (triggers, conditions, flow), use template substitution
            sb.Append(GenerateStructuredNode(node, nodeDef, entity, questName, indent));
        }

        return sb.ToString();
    }

    /// <summary>
    /// Processes a node's template, replacing placeholders with config values.
    /// Text and string properties are escaped to prevent Lua syntax errors.
    /// </summary>
    private string ProcessNodeTemplate(NodeDefinition nodeDef, BehaviorNode node, string questName)
    {
        string code = nodeDef.CodeTemplate;

        code = code.Replace("{QUEST_NAME}", Escape(questName));

        // Build a lookup of property types for escaping decisions
        var propertyTypes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                propertyTypes[propDef.Name] = propDef.Type;
            }
        }

        // Apply config values from the node (with proper escaping for text/string types)
        foreach (var prop in node.Config)
        {
            string placeholder = "{" + prop.Key + "}";
            string value = prop.Value?.ToString() ?? "";

            // Escape text and string properties to prevent Lua syntax errors from quotes/special chars
            if (propertyTypes.TryGetValue(prop.Key, out string? propType) &&
                (propType == "text" || propType == "string"))
            {
                value = Escape(value);
            }

            code = code.Replace(placeholder, value);
        }

        // Apply default values for missing properties (with proper escaping)
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                string placeholder = "{" + propDef.Name + "}";
                if (code.Contains(placeholder))
                {
                    string defaultValue = propDef.DefaultValue?.ToString() ?? "";

                    // Escape text and string default values
                    if (propDef.Type == "text" || propDef.Type == "string")
                    {
                        defaultValue = Escape(defaultValue);
                    }

                    code = code.Replace(placeholder, defaultValue);
                }
            }
        }

        return code;
    }

    /// <summary>
    /// Generates code for structured nodes (triggers, conditions, flow control).
    /// Children are indented inside the control structure.
    /// </summary>
    private string GenerateStructuredNode(BehaviorNode node, NodeDefinition nodeDef, QuestEntity entity, string questName, int indent)
    {
        StringBuilder sb = new StringBuilder();
        string code = ProcessNodeTemplate(nodeDef, node, questName);

        // Handle children (connected nodes)
        var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
        
        if (nodeDef.HasBranching)
        {
            // Branching nodes (if/else) - children go into specific branches at indent+1
            var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
            var branchCode = new Dictionary<string, StringBuilder>();

            foreach (var label in branchLabels)
            {
                branchCode[label] = new StringBuilder();
            }

            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null && !string.IsNullOrEmpty(conn.FromPort))
                {
                    string childCode = GenerateNodeCode(childNode, entity, questName, indent + 1);
                    if (branchCode.ContainsKey(conn.FromPort))
                    {
                        branchCode[conn.FromPort].Append(childCode);
                    }
                }
            }

            foreach (var label in branchLabels)
            {
                string placeholder = "{" + label + "}";
                string placeholderUpper = "{" + label.ToUpper() + "}";
                string branchContent = branchCode[label].Length > 0
                    ? branchCode[label].ToString().TrimEnd('\n')
                    : GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";

                code = code.Replace(placeholder, branchContent);
                code = code.Replace(placeholderUpper, branchContent);
            }
        }
        else if (connections.Count > 0)
        {
            // Non-branching structured node (trigger) - children go inside at indent+1
            StringBuilder childrenCode = new StringBuilder();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    childrenCode.Append(GenerateNodeCode(childNode, entity, questName, indent + 1));
                }
            }
            code = code.Replace("{CHILDREN}", childrenCode.ToString().TrimEnd('\n'));
        }
        else
        {
            // No connections - clear placeholders
            code = code.Replace("{CHILDREN}", "");
            
            if (nodeDef.HasBranching)
            {
                var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
                foreach (var label in branchLabels)
                {
                    string placeholder = "{" + label + "}";
                    string placeholderUpper = "{" + label.ToUpper() + "}";
                    string comment = GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";
                    code = code.Replace(placeholder, comment);
                    code = code.Replace(placeholderUpper, comment);
                }
            }
        }

        // Emit code with proper indentation
        // Lines that are already indented (from child substitution) are emitted as-is
        foreach (string line in code.Split('\n'))
        {
            if (string.IsNullOrWhiteSpace(line))
            {
                continue;
            }
            
            // Check if line is already indented (from child code substitution)
            bool alreadyIndented = line.Length > 0 && (line[0] == ' ' || line[0] == '\t');
            
            if (alreadyIndented)
            {
                sb.AppendLine(line);
            }
            else
            {
                sb.AppendLine(GenerateIndent(indent) + line);
            }
        }

        return sb.ToString();
    }

    private static string Escape(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;

        return text
            .Replace("\\", "\\\\")  // Must be first to avoid double-escaping
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t")
            .Replace("\0", "");     // Remove null characters
    }
}