using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using FableQuestTool.Data;
using FableQuestTool.Models;

namespace FableQuestTool.Services;

public sealed class CodeGenerator
{
    // Set of node types that are cinematic/async and need pauses after them
    private static readonly HashSet<string> CinematicNodeTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "letterbox", "letterboxOff", "screenFadeOut", "screenFadeIn", "overrideMusic", 
        "stopMusicOverride", "cameraOrbitEntity", "cameraLookAtEntity", "cameraResetToHero",
        "cameraUseCameraPoint", "cameraConversation", "cameraCircleAroundThing",
        "startConversation", "addConversationLine", "endConversation",
        "radialBlur", "radialBlurOff", "colorFilter", "colorFilterOff",
        "playMovie", "startMovieSequence", "endMovieSequence"
    };

    public string GenerateQuestScript(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {quest.Name}.lua");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("Quest = nil");
        sb.AppendLine();

        // Generate Init function
        GenerateInitFunction(sb, quest);

        // Generate Main function
        GenerateMainFunction(sb, quest);

        // Generate OnPersist function
        GenerateOnPersistFunction(sb, quest);

        // Generate EntitySpawner thread if needed
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) || 
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            GenerateEntitySpawnerThread(sb, quest);
        }

        // Generate MonitorQuestCompletion thread
        GenerateMonitorQuestCompletion(sb, quest);

        // Generate user-defined threads
        foreach (QuestThread thread in quest.Threads)
        {
            GenerateUserThread(sb, thread);
        }

        // Generate CompleteQuest function
        GenerateCompleteQuestFunction(sb, quest);

        return sb.ToString();
    }

    public string GenerateEntityScript(QuestProject quest, QuestEntity entity)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {entity.ScriptName}.lua");
        sb.AppendLine($"-- Entity script for {quest.Name}");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("local Quest = nil");
        sb.AppendLine("local Me = nil");
        sb.AppendLine();
        sb.AppendLine("function Init(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Init called\")");

        // Entity control settings
        if (entity.MakeBehavioral)
        {
            sb.AppendLine("    Me:MakeBehavioral()");
        }
        if (entity.ExclusiveControl)
        {
            sb.AppendLine("    Me:TakeExclusiveControl()");
        }
        else if (entity.AcquireControl)
        {
            sb.AppendLine("    Me:AcquireControl()");
        }

        sb.AppendLine("end");
        sb.AppendLine();
        sb.AppendLine("function Main(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Main started\")");
        sb.AppendLine("    local hero = Quest:GetHero()");

        // Entity properties
        if (entity.Invulnerable)
        {
            sb.AppendLine("    Quest:EntitySetAsDamageable(Me, false)");
        }
        if (entity.Unkillable)
        {
            sb.AppendLine("    Quest:EntitySetAsKillable(Me, false)");
        }
        if (entity.Persistent)
        {
            sb.AppendLine("    Quest:SetThingPersistent(Me, true)");
        }
        if (entity.KillOnLevelUnload)
        {
            sb.AppendLine("    Me:SetToKillOnLevelUnload(true)");
        }

        sb.AppendLine();

        if (entity.Nodes.Count > 0)
        {
            sb.AppendLine("    -- Main behavior loop");
            sb.AppendLine("    while true do");
            
            // FIX: Add loop timing at the START of each iteration
            sb.AppendLine("        Quest:Pause(0.1)");
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine();

            // Generate code from node graph
            string behaviorCode = GenerateBehaviorCode(entity, quest.Name, 2);
            sb.Append(behaviorCode);

            sb.AppendLine();
            sb.AppendLine("        if Me:IsNull() then break end");
            sb.AppendLine("    end");
        }
        else if (entity.AcquireControl || entity.ExclusiveControl)
        {
            // Entity has control but no behavior nodes - add minimal loop
            sb.AppendLine("    -- Minimal behavior loop (add behavior nodes for triggers and actions)");
            sb.AppendLine("    while true do");
            sb.AppendLine("        Quest:Pause(0.1)");
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("        -- Add trigger nodes in the visual editor to respond to hero interactions");
            sb.AppendLine("        if Me:IsNull() then break end");
            sb.AppendLine("    end");
        }

        sb.AppendLine();
        sb.AppendLine("    Me:ReleaseControl()");
        sb.AppendLine("end");

        return sb.ToString();
    }

    public string GenerateRegistrationSnippet(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("-- Add this entry inside the Quests table in quests.lua");
        sb.Append(GenerateQuestLuaEntry(quest));
        return sb.ToString();
    }

    private void GenerateInitFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Init(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Init phase started.\")");

        // Add quest regions
        foreach (string region in quest.Regions)
        {
            sb.AppendLine($"    Quest:AddQuestRegion(\"{quest.Name}\", \"{region}\")");
        }

        // Set world map offset
        var mapOffset = GetWorldMapOffset(quest);
        sb.AppendLine($"    Quest:SetQuestWorldMapOffset(\"{quest.Name}\", {mapOffset.X}, {mapOffset.Y})");

        // Initialize QuestCompleted state
        sb.AppendLine("    Quest:SetStateBool(\"QuestCompleted\", false)");

        // Initialize user-defined states
        foreach (QuestState state in quest.States)
        {
            sb.AppendLine(RenderStateInit(state));
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateMainFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Main(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Main() started.\")");
        sb.AppendLine();

        // Bind entity scripts
        if (quest.Entities.Count > 0)
        {
            sb.AppendLine("    -- Bind entity scripts");
            foreach (QuestEntity entity in quest.Entities)
            {
                sb.AppendLine($"    Quest:AddEntityBinding(\"{entity.ScriptName}\", \"{quest.Name}/Entities/{entity.ScriptName}\")");
            }
            sb.AppendLine("    Quest:FinalizeEntityBindings()");
            sb.AppendLine();
        }

        // Quest card configuration
        if (!string.IsNullOrWhiteSpace(quest.QuestCardObject))
        {
            sb.AppendLine("    -- Configure quest card");
            if (quest.IsGuildQuest)
            {
                sb.AppendLine($"    Quest:AddGuildQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }
            else if (quest.GiveCardDirectly)
            {
                sb.AppendLine($"    Quest:GiveQuestCardDirectly(\"{quest.QuestCardObject}\", \"{quest.Name}\", true)");
            }
            else
            {
                sb.AppendLine($"    Quest:AddQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }

            if (!string.IsNullOrWhiteSpace(quest.ObjectiveText))
            {
                string region1 = quest.ObjectiveRegion1 ?? quest.Regions.FirstOrDefault() ?? "";
                string region2 = quest.ObjectiveRegion2 ?? "";
                sb.AppendLine($"    Quest:SetQuestCardObjective(\"{quest.Name}\", \"{Escape(quest.ObjectiveText)}\", \"{region1}\", \"{region2}\")");
            }

            if (quest.Rewards.Gold > 0)
            {
                sb.AppendLine($"    Quest:SetQuestGoldReward(\"{quest.Name}\", {quest.Rewards.Gold})");
            }

            if (quest.Rewards.Renown > 0)
            {
                sb.AppendLine($"    Quest:SetQuestRenownReward(\"{quest.Name}\", {quest.Rewards.Renown})");
            }
            sb.AppendLine();
        }

        // Show quest start screen
        if (quest.UseQuestStartScreen)
        {
            string isStory = quest.IsStoryQuest ? "true" : "false";
            string isGold = quest.IsGoldQuest ? "true" : "false";
            sb.AppendLine("    -- Show quest start screen");
            sb.AppendLine($"    Quest:KickOffQuestStartScreen(\"{quest.Name}\", {isStory}, {isGold})");
            sb.AppendLine();
        }

        // Start threads
        sb.AppendLine("    -- Start quest threads");
        
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";
        
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) ||
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            sb.AppendLine($"    Quest:CreateThread(\"EntitySpawner\", {{region=\"{primaryRegion}\"}})");
        }

        sb.AppendLine($"    Quest:CreateThread(\"MonitorQuestCompletion\", {{region=\"{primaryRegion}\"}})");

        foreach (QuestThread thread in quest.Threads)
        {
            sb.AppendLine($"    Quest:CreateThread(\"{thread.FunctionName}\", {{region=\"{thread.Region}\"}})");
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateOnPersistFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function OnPersist(questObject, context)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Quest:PersistTransferBool(context, \"QuestCompleted\")");

        foreach (QuestState state in quest.States)
        {
            if (state.Persist)
            {
                sb.AppendLine(RenderStatePersist(state));
            }
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateEntitySpawnerThread(StringBuilder sb, QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";

        sb.AppendLine("function EntitySpawner(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    -- Thread is region-bound to {primaryRegion} - FSE auto-waits for region load");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner executing (region is loaded).\")");
        sb.AppendLine();
        sb.AppendLine("    -- Brief pause to let game settle after region load");
        sb.AppendLine("    Quest:Pause(0.5)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
        sb.AppendLine();

        // Spawn entities
        var entitiesToSpawn = quest.Entities.Where(e => e.SpawnMethod != SpawnMethod.BindExisting).ToList();
        if (entitiesToSpawn.Count > 0)
        {
            sb.AppendLine("    -- Spawn entities");
            foreach (QuestEntity entity in entitiesToSpawn)
            {
                string spawnCode = GenerateEntitySpawnCode(entity);
                if (!string.IsNullOrWhiteSpace(spawnCode))
                {
                    sb.AppendLine(spawnCode);
                    sb.AppendLine();
                }
            }
        }

        // Set up quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("    -- Set up quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"    local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"    if {entity.ScriptName} ~= nil then");
                
                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"        Quest:SetThingHasInformation({entity.ScriptName}, true)");
                }
                
                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"        Quest:MiniMapAddMarker({entity.ScriptName}, \"{entity.ScriptName}\")");
                }
                
                sb.AppendLine("    end");
            }
            sb.AppendLine();
        }

        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner completed.\")");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private string GenerateEntitySpawnCode(QuestEntity entity)
    {
        return entity.SpawnMethod switch
        {
            SpawnMethod.AtMarker => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.AtPosition => GenerateCreateCreatureAtPosition(entity),
            SpawnMethod.CreateCreature => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.OnEntity => GenerateCreateCreatureOnEntity(entity),
            _ => string.Empty
        };
    }

    private string GenerateCreateCreatureAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local {entity.ScriptName} = Quest:CreateCreatureOnEntity(""{entity.DefName}"", targetEntity_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private void GenerateMonitorQuestCompletion(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function MonitorQuestCompletion(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Quest:GetStateBool(\"QuestCompleted\") then");
        sb.AppendLine("            CompleteQuest()");
        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine("        Quest:Pause(0.5)");
        sb.AppendLine("        if not Quest:NewScriptFrame() then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateUserThread(StringBuilder sb, QuestThread thread)
    {
        sb.AppendLine($"function {thread.FunctionName}(questObject)");
        sb.AppendLine("    Quest = questObject");
        if (!string.IsNullOrWhiteSpace(thread.Description))
        {
            sb.AppendLine($"    -- {thread.Description}");
        }
        sb.AppendLine("    -- TODO: Implement thread logic");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateCompleteQuestFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function CompleteQuest()");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: CompleteQuest called.\")");

        // Clear quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine();
            sb.AppendLine("    -- Clear quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"    local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"    if {entity.ScriptName} ~= nil then");
                
                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"        Quest:ClearThingHasInformation({entity.ScriptName})");
                }
                
                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"        Quest:MiniMapRemoveMarker({entity.ScriptName})");
                }
                
                sb.AppendLine("    end");
            }
        }

        sb.AppendLine();
        sb.AppendLine("    -- Give rewards");

        if (quest.Rewards.Gold > 0)
        {
            sb.AppendLine($"    Quest:GiveHeroGold({quest.Rewards.Gold})");
        }
        if (quest.Rewards.Experience > 0)
        {
            sb.AppendLine($"    Quest:GiveHeroExperience({quest.Rewards.Experience})");
        }
        if (quest.Rewards.Renown > 0)
        {
            sb.AppendLine($"    Quest:GiveHeroRenownPoints({quest.Rewards.Renown})");
        }
        if (quest.Rewards.Morality != 0)
        {
            sb.AppendLine($"    Quest:GiveHeroMorality({quest.Rewards.Morality})");
        }
        foreach (string item in quest.Rewards.Items)
        {
            sb.AppendLine($"    Quest:GiveHeroObject(\"{item}\", 1)");
        }

        sb.AppendLine();
        sb.AppendLine("    -- Complete and deactivate quest");
        sb.AppendLine($"    Quest:SetQuestAsCompleted(\"{quest.Name}\", false, false, false)");
        sb.AppendLine($"    Quest:DeactivateQuestLater(\"{quest.Name}\", 1.0)");
        sb.AppendLine("end");
    }

    private (int X, int Y) GetWorldMapOffset(QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "";
        return WorldMapCoordinateService.GetMapOffsetForQuest(primaryRegion, quest.Entities);
    }

    private string RenderStateInit(QuestState state)
    {
        string value = state.DefaultValue?.ToString() ?? GetDefaultForType(state.Type);
        
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:SetStateBool(\"{state.Name}\", {value.ToLowerInvariant()})",
            "int" => $"    Quest:SetStateInt(\"{state.Name}\", {value})",
            "float" => $"    Quest:SetStateFloat(\"{state.Name}\", {value})",
            "string" => $"    Quest:SetStateString(\"{state.Name}\", \"{value}\")",
            _ => $"    Quest:SetStateBool(\"{state.Name}\", false) -- Unknown type: {state.Type}"
        };
    }

    private string RenderStatePersist(QuestState state)
    {
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:PersistTransferBool(context, \"{state.Name}\")",
            "int" => $"    Quest:PersistTransferInt(context, \"{state.Name}\")",
            "float" => $"    Quest:PersistTransferFloat(context, \"{state.Name}\")",
            "string" => $"    Quest:PersistTransferString(context, \"{state.Name}\")",
            _ => $"    Quest:PersistTransferBool(context, \"{state.Name}\") -- Unknown type: {state.Type}"
        };
    }

    private string GenerateQuestLuaEntry(QuestProject quest)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    {quest.Name} = {{");
        sb.AppendLine($"        name = \"{quest.Name}\",");
        sb.AppendLine($"        file = \"{quest.Name}/{quest.Name}\",");
        sb.AppendLine($"        id = {quest.Id},");
        sb.AppendLine();
        sb.AppendLine("        entity_scripts = {");

        int entityId = quest.Id + 1;
        foreach (QuestEntity entity in quest.Entities)
        {
            sb.AppendLine($"            {{ name = \"{entity.ScriptName}\", file = \"{quest.Name}/Entities/{entity.ScriptName}\", id = {entityId} }},");
            entityId++;
        }

        sb.AppendLine("        }");
        sb.Append("    },");

        return sb.ToString();
    }

    private static string GetDefaultForType(string type)
    {
        return type.ToLowerInvariant() switch
        {
            "bool" => "false",
            "int" => "0",
            "float" => "0.0",
            "string" => "",
            _ => "false"
        };
    }

    public string GenerateBehaviorCode(QuestEntity entity, string questName, int indent = 2)
    {
        if (entity.Nodes.Count == 0)
        {
            return GenerateIndent(indent) + "-- No behavior nodes defined\n";
        }

        StringBuilder sb = new StringBuilder();

        // Find all trigger nodes (entry points)
        var triggerNodes = entity.Nodes.Where(n => n.Category == "trigger").ToList();

        if (triggerNodes.Count == 0)
        {
            sb.AppendLine(GenerateIndent(indent) + "-- No trigger nodes found");
            return sb.ToString();
        }

        // Generate code for each trigger
        foreach (var trigger in triggerNodes)
        {
            sb.Append(GenerateNodeCode(trigger, entity, questName, indent));
        }

        return sb.ToString();
    }

    private static string GenerateIndent(int level)
    {
        return new string(' ', level * 4);
    }

    /// <summary>
    /// Generates Lua code for a behavior node and its children.
    /// Handles both structured nodes (triggers, conditions) and linear action sequences.
    /// </summary>
    private string GenerateNodeCode(BehaviorNode node, QuestEntity entity, string questName, int indent)
    {
        var nodeDef = NodeDefinitions.GetAllNodes().FirstOrDefault(n => n.Type == node.Type);
        if (nodeDef == null)
        {
            return GenerateIndent(indent) + $"-- Unknown node type: {node.Type}\n";
        }

        StringBuilder sb = new StringBuilder();

        // Check if this is a linear action (non-branching action node)
        bool isLinearAction = nodeDef.Category == "action" && !nodeDef.HasBranching;

        if (isLinearAction)
        {
            // For linear actions, emit THIS node's code at current indent,
            // then emit children at SAME indent (not nested)
            string code = ProcessNodeTemplate(nodeDef, node, questName);
            
            // Remove {CHILDREN} - we handle sequencing explicitly
            code = code.Replace("{CHILDREN}", "").TrimEnd();

            // Emit this node's code lines
            foreach (string line in code.Split('\n'))
            {
                if (!string.IsNullOrWhiteSpace(line))
                {
                    sb.AppendLine(GenerateIndent(indent) + line);
                }
            }

            // Process children at SAME indent level (linear sequence, not nested)
            var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    sb.Append(GenerateNodeCode(childNode, entity, questName, indent)); // Same indent!
                }
            }
        }
        else
        {
            // For structured nodes (triggers, conditions, flow), use template substitution
            sb.Append(GenerateStructuredNode(node, nodeDef, entity, questName, indent));
        }

        return sb.ToString();
    }

    /// <summary>
    /// Processes a node's template, replacing placeholders with config values.
    /// </summary>
    private string ProcessNodeTemplate(NodeDefinition nodeDef, BehaviorNode node, string questName)
    {
        string code = nodeDef.CodeTemplate;
        
        code = code.Replace("{QUEST_NAME}", questName);

        // Apply config values from the node
        foreach (var prop in node.Config)
        {
            string placeholder = "{" + prop.Key + "}";
            string value = prop.Value?.ToString() ?? "";
            code = code.Replace(placeholder, value);
        }

        // Apply default values for missing properties
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                string placeholder = "{" + propDef.Name + "}";
                if (code.Contains(placeholder))
                {
                    string defaultValue = propDef.DefaultValue?.ToString() ?? "";
                    code = code.Replace(placeholder, defaultValue);
                }
            }
        }

        return code;
    }

    /// <summary>
    /// Generates code for structured nodes (triggers, conditions, flow control).
    /// Children are indented inside the control structure.
    /// </summary>
    private string GenerateStructuredNode(BehaviorNode node, NodeDefinition nodeDef, QuestEntity entity, string questName, int indent)
    {
        StringBuilder sb = new StringBuilder();
        string code = ProcessNodeTemplate(nodeDef, node, questName);

        // Handle children (connected nodes)
        var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
        
        if (nodeDef.HasBranching)
        {
            // Branching nodes (if/else) - children go into specific branches at indent+1
            var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
            var branchCode = new Dictionary<string, StringBuilder>();

            foreach (var label in branchLabels)
            {
                branchCode[label] = new StringBuilder();
            }

            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null && !string.IsNullOrEmpty(conn.FromPort))
                {
                    string childCode = GenerateNodeCode(childNode, entity, questName, indent + 1);
                    if (branchCode.ContainsKey(conn.FromPort))
                    {
                        branchCode[conn.FromPort].Append(childCode);
                    }
                }
            }

            foreach (var label in branchLabels)
            {
                string placeholder = "{" + label + "}";
                string placeholderUpper = "{" + label.ToUpper() + "}";
                string branchContent = branchCode[label].Length > 0
                    ? branchCode[label].ToString().TrimEnd('\n')
                    : GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";

                code = code.Replace(placeholder, branchContent);
                code = code.Replace(placeholderUpper, branchContent);
            }
        }
        else if (connections.Count > 0)
        {
            // Non-branching structured node (trigger) - children go inside at indent+1
            StringBuilder childrenCode = new StringBuilder();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    childrenCode.Append(GenerateNodeCode(childNode, entity, questName, indent + 1));
                }
            }
            code = code.Replace("{CHILDREN}", childrenCode.ToString().TrimEnd('\n'));
        }
        else
        {
            // No connections - clear placeholders
            code = code.Replace("{CHILDREN}", "");
            
            if (nodeDef.HasBranching)
            {
                var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
                foreach (var label in branchLabels)
                {
                    string placeholder = "{" + label + "}";
                    string placeholderUpper = "{" + label.ToUpper() + "}";
                    string comment = GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";
                    code = code.Replace(placeholder, comment);
                    code = code.Replace(placeholderUpper, comment);
                }
            }
        }

        // Emit code with proper indentation
        // Lines that are already indented (from child substitution) are emitted as-is
        foreach (string line in code.Split('\n'))
        {
            if (string.IsNullOrWhiteSpace(line))
            {
                continue;
            }
            
            // Check if line is already indented (from child code substitution)
            bool alreadyIndented = line.Length > 0 && (line[0] == ' ' || line[0] == '\t');
            
            if (alreadyIndented)
            {
                sb.AppendLine(line);
            }
            else
            {
                sb.AppendLine(GenerateIndent(indent) + line);
            }
        }

        return sb.ToString();
    }

    private static string Escape(string text)
    {
        return text.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
    }
}