using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using FableQuestTool.Data;
using FableQuestTool.Models;

namespace FableQuestTool.Services;

public sealed class CodeGenerator
{
    public string GenerateQuestScript(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {quest.Name}.lua");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("Quest = nil");
        sb.AppendLine();

        // Generate Init function
        GenerateInitFunction(sb, quest);

        // Generate Main function
        GenerateMainFunction(sb, quest);

        // Generate OnPersist function
        GenerateOnPersistFunction(sb, quest);

        // Generate EntitySpawner thread if needed
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) || 
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            GenerateEntitySpawnerThread(sb, quest);
        }

        // Generate MonitorQuestCompletion thread
        GenerateMonitorQuestCompletion(sb, quest);

        // Generate user-defined threads
        foreach (QuestThread thread in quest.Threads)
        {
            GenerateUserThread(sb, thread);
        }

        // Generate CompleteQuest function
        GenerateCompleteQuestFunction(sb, quest);

        return sb.ToString();
    }

    public string GenerateEntityScript(QuestProject quest, QuestEntity entity)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {entity.ScriptName}.lua");
        sb.AppendLine($"-- Entity script for {quest.Name}");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("local Quest = nil");
        sb.AppendLine("local Me = nil");
        sb.AppendLine();
        sb.AppendLine("function Init(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Init called\")");

        // Entity control settings from old implementation
        if (entity.MakeBehavioral)
        {
            sb.AppendLine("    Me:MakeBehavioral()");
        }
        if (entity.ExclusiveControl)
        {
            sb.AppendLine("    Me:TakeExclusiveControl()");
        }
        else if (entity.AcquireControl)
        {
            sb.AppendLine("    Me:AcquireControl()");
        }

        sb.AppendLine("end");
        sb.AppendLine();
        sb.AppendLine("function Main(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Main started\")");
        sb.AppendLine("    local hero = Quest:GetHero()");

        // Entity properties from old implementation
        if (entity.Invulnerable)
        {
            sb.AppendLine("    Quest:EntitySetAsDamageable(Me, false)");
        }
        if (entity.Unkillable)
        {
            sb.AppendLine("    Quest:EntitySetAsKillable(Me, false)");
        }
        if (entity.Persistent)
        {
            sb.AppendLine("    Quest:SetThingPersistent(Me, true)");
        }
        if (entity.KillOnLevelUnload)
        {
            sb.AppendLine("    Me:SetToKillOnLevelUnload(true)");
        }

        sb.AppendLine();

        if (entity.Nodes.Count > 0)
        {
            sb.AppendLine("    -- Main behavior loop");
            sb.AppendLine("    while true do");

            // Generate code from node graph using old implementation style
            string behaviorCode = GenerateBehaviorCode(entity, quest.Name, 2);
            sb.Append(behaviorCode);

            sb.AppendLine();
            sb.AppendLine("        if Me:IsNull() then break end");
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }
        else if (entity.AcquireControl || entity.ExclusiveControl)
        {
            // Entity has control but no behavior nodes - add minimal loop to keep entity active
            // and allow it to respond to game events (can be customized by user)
            sb.AppendLine("    -- Minimal behavior loop (add behavior nodes for triggers and actions)");
            sb.AppendLine("    while true do");
            sb.AppendLine("        -- Add trigger nodes in the visual editor to respond to hero interactions");
            sb.AppendLine("        if Me:IsNull() then break end");
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }

        sb.AppendLine();
        sb.AppendLine("    Me:ReleaseControl()");
        sb.AppendLine("end");

        return sb.ToString();
    }

    public string GenerateRegistrationSnippet(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("-- Add this entry inside the Quests table in quests.lua");
        sb.Append(GenerateQuestLuaEntry(quest));
        return sb.ToString();
    }

    private void GenerateInitFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Init(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Init phase started.\")");

        // Add quest regions
        foreach (string region in quest.Regions)
        {
            sb.AppendLine($"    Quest:AddQuestRegion(\"{quest.Name}\", \"{region}\")");
        }

        // Set world map offset (auto-calculate if not manually set)
        var mapOffset = GetWorldMapOffset(quest);
        sb.AppendLine($"    Quest:SetQuestWorldMapOffset(\"{quest.Name}\", {mapOffset.X}, {mapOffset.Y})");

        // Initialize QuestCompleted state for monitoring
        sb.AppendLine("    Quest:SetStateBool(\"QuestCompleted\", false)");

        // Initialize user-defined states
        foreach (QuestState state in quest.States)
        {
            sb.AppendLine(RenderStateInit(state));
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateMainFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Main(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Main() started.\")");
        sb.AppendLine();

        // Bind entity scripts (must be done before spawning)
        if (quest.Entities.Count > 0)
        {
            sb.AppendLine("    -- Bind entity scripts");
            foreach (QuestEntity entity in quest.Entities)
            {
                sb.AppendLine($"    Quest:AddEntityBinding(\"{entity.ScriptName}\", \"{quest.Name}/Entities/{entity.ScriptName}\")");
            }
            sb.AppendLine("    Quest:FinalizeEntityBindings()");
            sb.AppendLine();
        }

        // Quest card configuration (immediate, no region wait needed)
        if (!string.IsNullOrWhiteSpace(quest.QuestCardObject))
        {
            sb.AppendLine("    -- Configure quest card");
            if (quest.IsGuildQuest)
            {
                sb.AppendLine($"    Quest:AddGuildQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }
            else if (quest.GiveCardDirectly)
            {
                sb.AppendLine($"    Quest:GiveQuestCardDirectly(\"{quest.QuestCardObject}\", \"{quest.Name}\", true)");
            }
            else
            {
                sb.AppendLine($"    Quest:AddQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }

            if (!string.IsNullOrWhiteSpace(quest.ObjectiveText))
            {
                string region1 = quest.ObjectiveRegion1 ?? quest.Regions.FirstOrDefault() ?? "";
                string region2 = quest.ObjectiveRegion2 ?? "";
                sb.AppendLine($"    Quest:SetQuestCardObjective(\"{quest.Name}\", \"{Escape(quest.ObjectiveText)}\", \"{region1}\", \"{region2}\")");
            }

            if (quest.Rewards.Gold > 0)
            {
                sb.AppendLine($"    Quest:SetQuestGoldReward(\"{quest.Name}\", {quest.Rewards.Gold})");
            }

            if (quest.Rewards.Renown > 0)
            {
                sb.AppendLine($"    Quest:SetQuestRenownReward(\"{quest.Name}\", {quest.Rewards.Renown})");
            }
            sb.AppendLine();
        }

        // Show quest start screen (immediate, no region wait)
        if (quest.UseQuestStartScreen)
        {
            string isStory = quest.IsStoryQuest ? "true" : "false";
            string isGold = quest.IsGoldQuest ? "true" : "false";
            sb.AppendLine("    -- Show quest start screen");
            sb.AppendLine($"    Quest:KickOffQuestStartScreen(\"{quest.Name}\", {isStory}, {isGold})");
            sb.AppendLine();
        }

        // Start threads - they will wait for their regions
        sb.AppendLine("    -- Start quest threads");
        
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";
        
        // Create EntitySpawner thread if we have entities to spawn
        // Note: Region-bound threads auto-wait for their region to load
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) ||
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            sb.AppendLine($"    Quest:CreateThread(\"EntitySpawner\", {{region=\"{primaryRegion}\"}})");
        }

        sb.AppendLine($"    Quest:CreateThread(\"MonitorQuestCompletion\", {{region=\"{primaryRegion}\"}})");

        // Start user-defined threads
        foreach (QuestThread thread in quest.Threads)
        {
            sb.AppendLine($"    Quest:CreateThread(\"{thread.FunctionName}\", {{region=\"{thread.Region}\"}})");
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateOnPersistFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function OnPersist(questObject, context)");
        sb.AppendLine("    Quest = questObject");

        // Persist QuestCompleted state
        sb.AppendLine("    Quest:PersistTransferBool(context, \"QuestCompleted\")");

        // Persist user-defined states
        foreach (QuestState state in quest.States)
        {
            if (state.Persist)
            {
                sb.AppendLine(RenderStatePersist(state));
            }
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates the EntitySpawner thread that spawns entities when the region is loaded.
    /// Thread is region-bound via CreateThread({region="..."}) so FSE automatically delays
    /// execution until the region loads. Do NOT add manual region-waiting loops here -
    /// they are redundant and can cause the thread to hang.
    /// </summary>
    private void GenerateEntitySpawnerThread(StringBuilder sb, QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";

        sb.AppendLine("function EntitySpawner(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    -- Thread is region-bound to {primaryRegion} - FSE auto-waits for region load");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner executing (region is loaded).\")");
        sb.AppendLine();

        // Brief pause to let game settle after region load
        sb.AppendLine("    -- Brief pause to let game settle after region load");
        sb.AppendLine("    Quest:Pause(0.5)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
        sb.AppendLine();

        // Spawn entities
        var entitiesToSpawn = quest.Entities.Where(e => e.SpawnMethod != SpawnMethod.BindExisting).ToList();
        if (entitiesToSpawn.Count > 0)
        {
            sb.AppendLine("    -- Spawn entities");
            foreach (QuestEntity entity in entitiesToSpawn)
            {
                string spawnCode = GenerateEntitySpawnCode(entity);
                if (!string.IsNullOrWhiteSpace(spawnCode))
                {
                    sb.AppendLine(spawnCode);
                    sb.AppendLine();
                }
            }
        }

        // Set up quest target highlighting and minimap markers
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("    -- Set up quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"    local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"    if {entity.ScriptName} ~= nil then");
                
                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"        Quest:SetThingHasInformation({entity.ScriptName}, true)");
                }
                
                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"        Quest:MiniMapAddMarker({entity.ScriptName}, \"{entity.ScriptName}\")");
                }
                
                sb.AppendLine("    end");
            }
            sb.AppendLine();
        }

        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner completed.\")");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private string GenerateEntitySpawnCode(QuestEntity entity)
    {
        return entity.SpawnMethod switch
        {
            SpawnMethod.AtMarker => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.AtPosition => GenerateCreateCreatureAtPosition(entity),
            SpawnMethod.CreateCreature => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.OnEntity => GenerateCreateCreatureOnEntity(entity),
            _ => string.Empty
        };
    }

    private string GenerateCreateCreatureAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local {entity.ScriptName} = Quest:CreateCreatureOnEntity(""{entity.DefName}"", targetEntity_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private void GenerateMonitorQuestCompletion(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function MonitorQuestCompletion(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Quest:GetStateBool(\"QuestCompleted\") then");
        sb.AppendLine("            CompleteQuest()");
        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine("        Quest:Pause(0.5)");
        sb.AppendLine("        if not Quest:NewScriptFrame() then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateUserThread(StringBuilder sb, QuestThread thread)
    {
        sb.AppendLine($"function {thread.FunctionName}(questObject)");
        sb.AppendLine("    Quest = questObject");
        if (!string.IsNullOrWhiteSpace(thread.Description))
        {
            sb.AppendLine($"    -- {thread.Description}");
        }
        sb.AppendLine("    -- TODO: Implement thread logic");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateCompleteQuestFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function CompleteQuest()");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: CompleteQuest called.\")");

        // Clear quest target highlighting before completion
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine();
            sb.AppendLine("    -- Clear quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"    local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"    if {entity.ScriptName} ~= nil then");
                
                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"        Quest:ClearThingHasInformation({entity.ScriptName})");
                }
                
                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"        Quest:MiniMapRemoveMarker({entity.ScriptName})");
                }
                
                sb.AppendLine("    end");
            }
        }

        // Give rewards
        sb.AppendLine();
        sb.AppendLine("    -- Give rewards");
        if (quest.Rewards.Gold > 0)
        {
            sb.AppendLine($"    Quest:GiveHeroGold({quest.Rewards.Gold})");
        }

        if (quest.Rewards.Experience > 0)
        {
            sb.AppendLine($"    Quest:GiveHeroExperience({quest.Rewards.Experience})");
        }

        if (quest.Rewards.Renown > 0)
        {
            sb.AppendLine($"    Quest:GiveHeroRenownPoints({quest.Rewards.Renown})");
        }

        if (quest.Rewards.Morality != 0)
        {
            sb.AppendLine($"    Quest:GiveHeroMorality({quest.Rewards.Morality})");
        }

        foreach (string item in quest.Rewards.Items)
        {
            if (!string.IsNullOrWhiteSpace(item))
            {
                sb.AppendLine($"    Quest:GiveHeroObject(\"{item}\", 1)");
            }
        }

        foreach (string ability in quest.Rewards.Abilities)
        {
            if (!string.IsNullOrWhiteSpace(ability))
            {
                sb.AppendLine($"    Quest:GiveHeroAbility(\"{ability}\")");
            }
        }

        sb.AppendLine();
        sb.AppendLine("    -- Complete and deactivate quest");
        sb.AppendLine($"    Quest:SetQuestAsCompleted(\"{quest.Name}\", false, false, false)");
        sb.AppendLine($"    Quest:DeactivateQuestLater(\"{quest.Name}\", 1.0)");
        sb.AppendLine("end");
    }

    /// <summary>
    /// Gets the world map offset for the quest, auto-calculating if not manually set.
    /// </summary>
    private (int X, int Y) GetWorldMapOffset(QuestProject quest)
    {
        // If user has manually set offsets, use them
        if (quest.WorldMapOffsetX != 0 || quest.WorldMapOffsetY != 0)
        {
            return (quest.WorldMapOffsetX, quest.WorldMapOffsetY);
        }

        // Otherwise, auto-calculate based on region and entities
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "";
        return WorldMapCoordinateService.GetMapOffsetForQuest(primaryRegion, quest.Entities);
    }



    private string RenderStateInit(QuestState state)
    {
        string value = state.DefaultValue?.ToString() ?? GetDefaultForType(state.Type);
        
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:SetStateBool(\"{state.Name}\", {value.ToLowerInvariant()})",
            "int" => $"    Quest:SetStateInt(\"{state.Name}\", {value})",
            "float" => $"    Quest:SetStateFloat(\"{state.Name}\", {value})",
            "string" => $"    Quest:SetStateString(\"{state.Name}\", \"{value}\")",
            _ => $"    Quest:SetStateBool(\"{state.Name}\", false) -- Unknown type: {state.Type}"
        };
    }

    private string RenderStatePersist(QuestState state)
    {
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:PersistTransferBool(context, \"{state.Name}\")",
            "int" => $"    Quest:PersistTransferInt(context, \"{state.Name}\")",
            "float" => $"    Quest:PersistTransferFloat(context, \"{state.Name}\")",
            "string" => $"    Quest:PersistTransferString(context, \"{state.Name}\")",
            _ => $"    Quest:PersistTransferBool(context, \"{state.Name}\") -- Unknown type: {state.Type}"
        };
    }

    private string GenerateQuestLuaEntry(QuestProject quest)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    {quest.Name} = {{");
        sb.AppendLine($"        name = \"{quest.Name}\",");
        sb.AppendLine($"        file = \"{quest.Name}/{quest.Name}\",");
        sb.AppendLine($"        id = {quest.Id},");
        sb.AppendLine();
        sb.AppendLine("        entity_scripts = {");

        int entityId = quest.Id + 1;
        foreach (QuestEntity entity in quest.Entities)
        {
            sb.AppendLine($"            {{ name = \"{entity.ScriptName}\", file = \"{quest.Name}/Entities/{entity.ScriptName}\", id = {entityId} }},");
            entityId++;
        }

        sb.AppendLine("        }");
        sb.Append("    },");

        return sb.ToString();
    }

    private static string GetDefaultForType(string type)
    {
        return type.ToLowerInvariant() switch
        {
            "bool" => "false",
            "int" => "0",
            "float" => "0.0",
            "string" => "",
            _ => "false"
        };
    }

    public string GenerateBehaviorCode(QuestEntity entity, string questName, int indent = 2)
    {
        if (entity.Nodes.Count == 0)
        {
            return GenerateIndent(indent) + "-- No behavior nodes defined\n";
        }

        StringBuilder sb = new StringBuilder();

        // Find all trigger nodes (entry points)
        var triggerNodes = entity.Nodes.Where(n => n.Category == "trigger").ToList();

        if (triggerNodes.Count == 0)
        {
            sb.AppendLine(GenerateIndent(indent) + "-- No trigger nodes found");
            return sb.ToString();
        }

        // Generate code for each trigger
        foreach (var trigger in triggerNodes)
        {
            sb.Append(GenerateNodeCode(trigger, entity, questName, indent));
        }

        return sb.ToString();
    }

    private static string GenerateIndent(int level)
    {
        return new string(' ', level * 4);
    }


    private string GenerateNodeCode(BehaviorNode node, QuestEntity entity, string questName, int indent)
    {
        var nodeDef = NodeDefinitions.GetAllNodes().FirstOrDefault(n => n.Type == node.Type);
        if (nodeDef == null)
        {
            return GenerateIndent(indent) + $"-- Unknown node type: {node.Type}\n";
        }

        StringBuilder sb = new StringBuilder();
        string code = nodeDef.CodeTemplate;

        // Replace placeholders with actual values
        code = code.Replace("{QUEST_NAME}", questName);

        // First, apply actual config values from the node (these take priority)
        foreach (var prop in node.Config)
        {
            string placeholder = "{" + prop.Key + "}";
            string value = prop.Value?.ToString() ?? "";
            code = code.Replace(placeholder, value);
        }

        // Then, fill in any remaining placeholders with default values
        // This ensures new properties have values even if the saved project uses old property names
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                string placeholder = "{" + propDef.Name + "}";
                if (code.Contains(placeholder))
                {
                    string defaultValue = propDef.DefaultValue?.ToString() ?? "";
                    code = code.Replace(placeholder, defaultValue);
                }
            }
        }

        // Handle children (connected nodes)
        var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
        if (connections.Count > 0)
        {
            // Check if this node has branching (True/False outputs)
            bool hasBranching = nodeDef.HasBranching;

            if (hasBranching)
            {
                // Get branch labels from node definition (e.g., "True"/"False" or "Yes"/"No"/"Unsure")
                var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
                var branchCode = new Dictionary<string, StringBuilder>();

                // Initialize code builders for each branch
                foreach (var label in branchLabels)
                {
                    branchCode[label] = new StringBuilder();
                }

                // Route connections to their respective branches
                foreach (var conn in connections)
                {
                    var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                    if (childNode != null && !string.IsNullOrEmpty(conn.FromPort))
                    {
                        string childCode = GenerateNodeCode(childNode, entity, questName, indent + 1);

                        // Find matching branch by FromPort (case-sensitive exact match)
                        if (branchCode.ContainsKey(conn.FromPort))
                        {
                            branchCode[conn.FromPort].Append(childCode);
                        }
                    }
                }

                // Replace placeholders with branch code (or comments if empty)
                foreach (var label in branchLabels)
                {
                    string placeholder = "{" + label + "}";
                    string placeholderUpper = "{" + label.ToUpper() + "}";
                    string branchContent = branchCode[label].Length > 0
                        ? branchCode[label].ToString().TrimEnd('\n')
                        : GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";

                    // Replace both the original case and uppercase versions
                    code = code.Replace(placeholder, branchContent);
                    code = code.Replace(placeholderUpper, branchContent);
                }
            }
            else
            {
                // Normal linear flow (CHILDREN placeholder)
                StringBuilder childrenCode = new StringBuilder();
                foreach (var conn in connections)
                {
                    var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                    if (childNode != null)
                    {
                        childrenCode.Append(GenerateNodeCode(childNode, entity, questName, indent + 1));
                    }
                }
                code = code.Replace("{CHILDREN}", childrenCode.ToString().TrimEnd('\n'));
            }
        }
        else
        {
            // No connections - replace with placeholder comments for readability
            code = code.Replace("{CHILDREN}", "");

            // For branching nodes, add placeholder comments instead of empty strings
            if (nodeDef.HasBranching)
            {
                var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
                foreach (var label in branchLabels)
                {
                    string placeholder = "{" + label + "}";
                    string placeholderUpper = "{" + label.ToUpper() + "}";
                    string comment = GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";
                    code = code.Replace(placeholder, comment);
                    code = code.Replace(placeholderUpper, comment);
                }
            }
            else
            {
                code = code.Replace("{TRUE}", "");
                code = code.Replace("{FALSE}", "");
            }
        }

        // Apply indentation
        string[] lines = code.Split('\n');
        for (int i = 0; i < lines.Length; i++)
        {
            if (!string.IsNullOrWhiteSpace(lines[i]))
            {
                sb.AppendLine(GenerateIndent(indent) + lines[i]);
            }
            else
            {
                sb.AppendLine();
            }
        }

        return sb.ToString();
    }


    private static string Escape(string text)
    {
        return text.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
    }
}
