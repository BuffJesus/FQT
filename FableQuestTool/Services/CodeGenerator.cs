using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using FableQuestTool.Data;
using FableQuestTool.Models;

namespace FableQuestTool.Services;

/// <summary>
/// Converts visual quest projects into executable Lua scripts for the FSE runtime.
///
/// CodeGenerator is the core transpiler that transforms the visual node graph representation
/// of quest behaviors into Lua code that runs in Fable: The Lost Chapters via FSE (Fable Script Extender).
///
/// The generator produces several types of scripts:
/// - Quest Script: Main quest logic including Init(), Main(), OnPersist() functions and thread definitions
/// - Entity Scripts: Individual behavior scripts for each quest entity (NPCs, objects, etc.)
/// - Container Scripts: Special scripts for reward containers that need manual interaction
/// - Registration Snippets: Code to register the quest in the FSE quests.lua configuration
///
/// Generated code follows FSE conventions:
/// - Quest object methods are called via Quest:MethodName() syntax
/// - Entity methods are called via Me:MethodName() for the current entity or entity:MethodName() for others
/// - All blocking operations must be followed by Quest:NewScriptFrame() checks to yield to the game loop
/// - State persistence uses Quest:PersistTransfer*() methods in OnPersist()
/// </summary>
/// <remarks>
/// The code generation process:
/// 1. Parse the QuestProject model containing all quest configuration
/// 2. Generate the main quest script with Init/Main/OnPersist functions
/// 3. Generate thread functions (EntitySpawner, MonitorQuestCompletion, user threads)
/// 4. For each entity, generate an entity script from its behavior node graph
/// 5. Traverse node connections to produce sequential and branching Lua code
///
/// Node types are defined in NodeDefinitions.cs with code templates containing placeholders
/// like {propertyName} that get replaced with actual configured values.
/// </remarks>
public sealed class CodeGenerator
{
    /// <summary>
    /// Set of node types that are cinematic/async and need pauses after them.
    /// These nodes trigger game engine operations that take time to complete,
    /// so generated code must include appropriate waits after them.
    /// </summary>
    private static readonly HashSet<string> CinematicNodeTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "letterbox", "letterboxOff", "screenFadeOut", "screenFadeIn", "overrideMusic",
        "stopMusicOverride", "cameraOrbitEntity", "cameraLookAtEntity", "cameraResetToHero",
        "cameraUseCameraPoint", "cameraConversation", "cameraCircleAroundThing",
        "startConversation", "addConversationLine", "endConversation",
        "radialBlur", "radialBlurOff", "colorFilter", "colorFilterOff",
        "playMovie", "startMovieSequence", "endMovieSequence"
    };

    /// <summary>
    /// Generates the main quest Lua script containing all quest-level logic.
    ///
    /// The generated script includes:
    /// - Init(): Called when quest is first loaded, initializes state variables and registers regions
    /// - Main(): Called when quest starts, sets up entity bindings, quest cards, and starts threads
    /// - OnPersist(): Called for save/load, handles state persistence
    /// - EntitySpawner: Thread that spawns quest entities when regions load
    /// - MonitorQuestCompletion: Thread that watches for QuestCompleted state and gives rewards
    /// - User-defined threads from QuestProject.Threads
    /// </summary>
    /// <param name="quest">The quest project to generate code for</param>
    /// <returns>Complete Lua script as a string</returns>
    public string GenerateQuestScript(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {quest.Name}.lua");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("Quest = nil");
        sb.AppendLine();

        // Generate Init function
        GenerateInitFunction(sb, quest);

        // Generate Main function
        GenerateMainFunction(sb, quest);

        // Generate OnPersist function
        GenerateOnPersistFunction(sb, quest);

        // Generate EntitySpawner thread if needed
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) || 
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            GenerateEntitySpawnerThread(sb, quest);
        }

        // Generate MonitorQuestCompletion thread
        GenerateMonitorQuestCompletion(sb, quest);

        // Generate user-defined threads
        foreach (QuestThread thread in quest.Threads)
        {
            GenerateUserThread(sb, thread);
        }

        // CompleteQuest logic is now inlined in MonitorQuestCompletion thread to preserve thread context

        return sb.ToString();
    }

    /// <summary>
    /// Generates a Lua script for an individual quest entity.
    ///
    /// Entity scripts control the behavior of NPCs, creatures, objects, and other
    /// game entities managed by the quest. Each entity gets its own script that
    /// receives two objects: Quest (the parent quest) and Me (the entity itself).
    ///
    /// The generated script includes:
    /// - Init(): Called when entity is first bound, sets up control mode
    /// - Main(): Contains the behavior loop generated from the visual node graph
    /// - Event functions: Generated from defineEvent nodes, callable from other nodes
    ///
    /// The behavior loop continuously checks for triggers and executes actions
    /// until the entity is destroyed or the quest ends.
    /// </summary>
    /// <param name="quest">Parent quest project (for context like quest name)</param>
    /// <param name="entity">The entity to generate a script for</param>
    /// <returns>Complete entity Lua script as a string</returns>
    public string GenerateEntityScript(QuestProject quest, QuestEntity entity)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {entity.ScriptName}.lua");
        sb.AppendLine($"-- Entity script for {quest.Name}");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("local Quest = nil");
        sb.AppendLine("local Me = nil");
        sb.AppendLine();
        sb.AppendLine("function Init(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Init called\")");

        // Entity control settings
        if (entity.MakeBehavioral)
        {
            sb.AppendLine("    Me:MakeBehavioral()");
        }
        // Always use AcquireControl if enabled, as it works with SpeakAndWait
        // TakeExclusiveControl does NOT work with SpeakAndWait
        if (entity.AcquireControl)
        {
            sb.AppendLine("    Me:AcquireControl()");
        }
        else if (entity.ExclusiveControl)
        {
            sb.AppendLine("    Me:TakeExclusiveControl()");
        }

        sb.AppendLine("end");
        sb.AppendLine();
        sb.AppendLine("function Main(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Main started\")");
        sb.AppendLine("    local hero = Quest:GetHero()");
        AppendEntityVariableDeclarations(sb, entity, 1);

        // Entity properties
        if (entity.Invulnerable)
        {
            sb.AppendLine("    Quest:EntitySetAsDamageable(Me, false)");
        }
        if (entity.Unkillable)
        {
            sb.AppendLine("    Quest:EntitySetAsKillable(Me, false)");
        }
        if (entity.Persistent)
        {
            sb.AppendLine("    Quest:SetThingPersistent(Me, true)");
        }
        if (entity.KillOnLevelUnload)
        {
            sb.AppendLine("    Me:SetToKillOnLevelUnload(true)");
        }

        sb.AppendLine();

        // Check if this object entity has rewards configured
        bool hasObjectRewards = entity.EntityType == EntityType.Object &&
                               entity.ObjectReward != null &&
                               entity.ObjectReward.HasRewards;

        // Generate event function definitions BEFORE the main loop
        // These need to be at script scope, not inside the while loop
        string eventDefinitions = GenerateEventDefinitions(entity, quest.Name, 1);
        if (!string.IsNullOrEmpty(eventDefinitions))
        {
            sb.AppendLine("    -- Custom event functions");
            sb.Append(eventDefinitions);
            sb.AppendLine();
        }

        if (entity.Nodes.Count > 0)
        {
            sb.AppendLine("    -- Main behavior loop");
            sb.AppendLine("    while true do");

            // Generate code from node graph
            string behaviorCode = GenerateBehaviorCode(entity, quest.Name, 2);
            sb.Append(behaviorCode);

            sb.AppendLine();
            sb.AppendLine("        if Me:IsNull() then break end");
            // Frame check at END of loop only (like working MAssassinNPC example)
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }
        else if (hasObjectRewards)
        {
            // Object has rewards but no custom behavior nodes - auto-generate reward behavior
            GenerateObjectRewardBehavior(sb, entity);
        }
        else if (entity.AcquireControl || entity.ExclusiveControl)
        {
            // Entity has control but no behavior nodes - add minimal loop
            sb.AppendLine("    -- Minimal behavior loop (add behavior nodes for triggers and actions)");
            sb.AppendLine("    while true do");
            sb.AppendLine("        -- Add trigger nodes in the visual editor to respond to hero interactions");
            sb.AppendLine("        if Me:IsNull() then break end");
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }

        sb.AppendLine();
        sb.AppendLine("    Me:ReleaseControl()");
        sb.AppendLine("end");

        return sb.ToString();
    }

    /// <summary>
    /// Generates an entity script for a container that gives multiple items when manually opened.
    /// This is used for quest-level container rewards when AutoGiveOnComplete is disabled.
    /// </summary>
    public string GenerateContainerEntityScript(QuestProject quest, ContainerReward container)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {container.ContainerScriptName}.lua");
        sb.AppendLine($"-- Container entity script for {quest.Name}");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("local Quest = nil");
        sb.AppendLine("local Me = nil");
        sb.AppendLine();
        sb.AppendLine("function Init(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{container.ContainerScriptName}: Init called\")");
        sb.AppendLine("    Me:AcquireControl()");
        sb.AppendLine("end");
        sb.AppendLine();
        sb.AppendLine("function Main(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{container.ContainerScriptName}: Main started - waiting for hero interaction\")");
        sb.AppendLine();
        sb.AppendLine("    -- Make container interactive");
        sb.AppendLine("    Quest:EntitySetTargetable(Me, true)");
        sb.AppendLine();
        sb.AppendLine("    -- Wait for hero to interact with container");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Me:MsgIsUsedByHero() then");
        sb.AppendLine($"            Quest:Log(\"{container.ContainerScriptName}: Hero opened container - giving rewards!\")");
        sb.AppendLine();

        // Give all items
        sb.AppendLine("            -- Give all items to hero");
        foreach (string item in container.Items)
        {
            sb.AppendLine($"            Quest:GiveHeroObject(\"{item}\", 1)");
        }

        sb.AppendLine();
        sb.AppendLine("            -- Clear highlight");
        sb.AppendLine("            Quest:ClearThingHasInformation(Me)");
        sb.AppendLine();
        sb.AppendLine("            -- Container opened - exit loop");
        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine();
        sb.AppendLine("        if Me:IsNull() then break end");
        sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
        sb.AppendLine("    end");
        sb.AppendLine();
        sb.AppendLine("    Me:ReleaseControl()");
        sb.AppendLine("end");

        return sb.ToString();
    }

    /// <summary>
    /// Checks if this quest needs a container entity script (for manual-opening containers).
    /// </summary>
    public bool NeedsContainerEntityScript(QuestProject quest)
    {
        return quest.Rewards.Container != null &&
               quest.Rewards.Container.Items.Count > 0 &&
               !quest.Rewards.Container.AutoGiveOnComplete;
    }

    public string GenerateRegistrationSnippet(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("-- Add this entry inside the Quests table in quests.lua");
        sb.Append(GenerateQuestLuaEntry(quest));
        return sb.ToString();
    }

    private void GenerateInitFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Init(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Init phase started.\")");

        // Add quest regions
        foreach (string region in quest.Regions)
        {
            sb.AppendLine($"    Quest:AddQuestRegion(\"{quest.Name}\", \"{region}\")");
        }

        // Set world map offset
        var mapOffset = GetWorldMapOffset(quest);
        sb.AppendLine($"    Quest:SetQuestWorldMapOffset(\"{quest.Name}\", {mapOffset.X}, {mapOffset.Y})");

        // Initialize QuestCompleted state
        sb.AppendLine("    Quest:SetStateBool(\"QuestCompleted\", false)");

        // Initialize user-defined states
        foreach (QuestState state in quest.States)
        {
            sb.AppendLine(RenderStateInit(state));
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateMainFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Main(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Main() started.\")");
        sb.AppendLine();

        // Check if we need container entity binding (for manual-opening containers)
        bool needsContainerEntity = quest.Rewards.Container != null &&
                                    quest.Rewards.Container.Items.Count > 0 &&
                                    !quest.Rewards.Container.AutoGiveOnComplete;

        // Bind entity scripts
        if (quest.Entities.Count > 0 || needsContainerEntity)
        {
            sb.AppendLine("    -- Bind entity scripts");
            foreach (QuestEntity entity in quest.Entities)
            {
                sb.AppendLine($"    Quest:AddEntityBinding(\"{entity.ScriptName}\", \"{quest.Name}/Entities/{entity.ScriptName}\")");
            }

            // Add container entity binding if needed
            if (needsContainerEntity)
            {
                var container = quest.Rewards.Container!;
                sb.AppendLine($"    Quest:AddEntityBinding(\"{container.ContainerScriptName}\", \"{quest.Name}/Entities/{container.ContainerScriptName}\")");
            }

            sb.AppendLine("    Quest:FinalizeEntityBindings()");
            sb.AppendLine();
        }

        // Quest card configuration
        if (!string.IsNullOrWhiteSpace(quest.QuestCardObject))
        {
            sb.AppendLine("    -- Configure quest card");
            if (quest.IsGuildQuest)
            {
                sb.AppendLine($"    Quest:AddQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }
            else if (quest.GiveCardDirectly)
            {
                sb.AppendLine($"    Quest:GiveQuestCardDirectly(\"{quest.QuestCardObject}\", \"{quest.Name}\", true)");
            }
            else
            {
                sb.AppendLine($"    Quest:AddQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }

            if (!string.IsNullOrWhiteSpace(quest.ObjectiveText))
            {
                string region1 = quest.ObjectiveRegion1 ?? quest.Regions.FirstOrDefault() ?? "";
                string region2 = quest.ObjectiveRegion2 ?? "";
                sb.AppendLine($"    Quest:SetQuestCardObjective(\"{quest.Name}\", \"{Escape(quest.ObjectiveText)}\", \"{region1}\", \"{region2}\")");
            }

            sb.AppendLine();
        }

        // Set quest rewards (for quest card and start screen display)
        // These must be set before KickOffQuestStartScreen for rewards to appear
        if (quest.Rewards.Gold > 0)
        {
            sb.AppendLine($"    Quest:SetQuestGoldReward(\"{quest.Name}\", {quest.Rewards.Gold})");
        }
        if (quest.Rewards.Renown > 0)
        {
            sb.AppendLine($"    Quest:SetQuestRenownReward(\"{quest.Name}\", {quest.Rewards.Renown})");
        }

        // Show quest start screen
        if (quest.UseQuestStartScreen)
        {
            string isStory = quest.IsStoryQuest ? "true" : "false";
            string isGold = quest.IsGoldQuest ? "true" : "false";
            sb.AppendLine();
            sb.AppendLine("    -- Set quest info for start screen");
            sb.AppendLine($"    Quest:SetQuestInfoName(\"{Escape(quest.DisplayName)}\")");

            // Build description with rewards info for start screen
            string description = BuildStartScreenDescription(quest);
            if (!string.IsNullOrWhiteSpace(description))
            {
                sb.AppendLine($"    Quest:SetQuestInfoText(\"{Escape(description)}\")");
            }

            sb.AppendLine("    -- Show quest start screen");
            sb.AppendLine($"    Quest:KickOffQuestStartScreen(\"{quest.Name}\", {isStory}, {isGold})");
            sb.AppendLine();
        }

        // Start threads
        sb.AppendLine("    -- Start quest threads");
        
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";
        
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) ||
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            sb.AppendLine($"    Quest:CreateThread(\"EntitySpawner\", {{region=\"{primaryRegion}\"}})");
        }

        sb.AppendLine($"    Quest:CreateThread(\"MonitorQuestCompletion\", {{region=\"{primaryRegion}\"}})");

        foreach (QuestThread thread in quest.Threads)
        {
            sb.AppendLine($"    Quest:CreateThread(\"{thread.FunctionName}\", {{region=\"{thread.Region}\"}})");
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateOnPersistFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function OnPersist(questObject, context)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    local QuestCompleted_value = Quest:GetStateBool(\"QuestCompleted\")");
        sb.AppendLine("    QuestCompleted_value = Quest:PersistTransferBool(context, \"QuestCompleted\", QuestCompleted_value)");
        sb.AppendLine("    Quest:SetStateBool(\"QuestCompleted\", QuestCompleted_value)");

        foreach (QuestState state in quest.States)
        {
            if (state.Persist)
            {
                sb.Append(RenderStatePersist(state));
            }
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateEntitySpawnerThread(StringBuilder sb, QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";

        sb.AppendLine("function EntitySpawner(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    -- Thread is region-bound to {primaryRegion} - FSE auto-waits for region load");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner executing (region is loaded).\")");
        sb.AppendLine();
        sb.AppendLine("    -- Brief pause to let game settle after region load");
        sb.AppendLine("    Quest:Pause(0.5)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
        sb.AppendLine();

        // Spawn entities
        var entitiesToSpawn = quest.Entities.Where(e => e.SpawnMethod != SpawnMethod.BindExisting).ToList();
        if (entitiesToSpawn.Count > 0)
        {
            sb.AppendLine("    -- Spawn entities");
            foreach (QuestEntity entity in entitiesToSpawn)
            {
                string spawnCode = GenerateEntitySpawnCode(entity);
                if (!string.IsNullOrWhiteSpace(spawnCode))
                {
                    sb.AppendLine(spawnCode);
                    sb.AppendLine();
                }
            }
        }

        // Set up quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("    -- Set up quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"    local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"    if {entity.ScriptName} ~= nil then");
                
                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"        Quest:SetThingHasInformation({entity.ScriptName}, true)");
                }
                
                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"        Quest:MiniMapAddMarker({entity.ScriptName}, \"{entity.ScriptName}\")");
                }
                
                sb.AppendLine("    end");
            }
            sb.AppendLine();
        }

        // Note: Container rewards are now spawned during quest completion, not here
        // This prevents issues with containers despawning before quest completes

        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner completed.\")");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private string GenerateEntitySpawnCode(QuestEntity entity)
    {
        // Use CreateObject for Object entities, CreateCreature for others
        if (entity.EntityType == EntityType.Object)
        {
            return entity.SpawnMethod switch
            {
                SpawnMethod.AtMarker => GenerateCreateObjectAtMarker(entity),
                SpawnMethod.AtPosition => GenerateCreateObjectAtPosition(entity),
                SpawnMethod.CreateCreature => GenerateCreateObjectAtMarker(entity),
                SpawnMethod.OnEntity => GenerateCreateObjectOnEntity(entity),
                _ => string.Empty
            };
        }

        return entity.SpawnMethod switch
        {
            SpawnMethod.AtMarker => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.AtPosition => GenerateCreateCreatureAtPosition(entity),
            SpawnMethod.CreateCreature => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.OnEntity => GenerateCreateCreatureOnEntity(entity),
            _ => string.Empty
        };
    }

    private string GenerateCreateCreatureAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local {entity.ScriptName} = Quest:CreateCreatureOnEntity(""{entity.DefName}"", targetEntity_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = targetEntity_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private void GenerateMonitorQuestCompletion(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function MonitorQuestCompletion(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Quest:GetStateBool(\"QuestCompleted\") then");
        sb.AppendLine($"            Quest:Log(\"{quest.Name}: Quest completed, giving rewards...\")");
        sb.AppendLine();

        // Clear quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("            -- Clear quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"            local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"            if {entity.ScriptName} ~= nil then");

                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"                Quest:ClearThingHasInformation({entity.ScriptName})");
                }

                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"                Quest:MiniMapRemoveMarker({entity.ScriptName})");
                }

                sb.AppendLine("            end");
            }
            sb.AppendLine();
        }

        // Give rewards
        sb.AppendLine("            -- Give rewards");
        if (quest.Rewards.Gold > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroGold({quest.Rewards.Gold})");
        }
        if (quest.Rewards.Experience > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroExperience({quest.Rewards.Experience})");
        }
        if (quest.Rewards.Renown > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroRenownPoints({quest.Rewards.Renown})");
        }
        if (quest.Rewards.Morality != 0)
        {
            sb.AppendLine($"            Quest:GiveHeroMorality({quest.Rewards.Morality})");
        }

        // Direct item rewards (instant give)
        if (quest.Rewards.Items.Count > 0)
        {
            foreach (string item in quest.Rewards.Items)
            {
                sb.AppendLine($"            Quest:GiveHeroObject(\"{item}\", 1)");
                sb.AppendLine("            Quest:Pause(0)");
            }
        }

        // Container-based rewards (for multiple items)
        if (quest.Rewards.Container != null && quest.Rewards.Container.Items.Count > 0)
        {
            GenerateContainerReward(sb, quest);
        }

        sb.AppendLine();
        sb.AppendLine("            -- Complete and deactivate quest");
        string showEndScreen = quest.UseQuestEndScreen ? "true" : "false";
        sb.AppendLine($"            Quest:SetQuestAsCompleted(\"{quest.Name}\", true, false, {showEndScreen})");
        sb.AppendLine($"            Quest:DeactivateQuestLater(\"{quest.Name}\", 0)");
        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine("        Quest:Pause(0.5)");
        sb.AppendLine("        if not Quest:NewScriptFrame() then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateUserThread(StringBuilder sb, QuestThread thread)
    {
        sb.AppendLine($"function {thread.FunctionName}(questObject)");
        sb.AppendLine("    Quest = questObject");
        if (!string.IsNullOrWhiteSpace(thread.Description))
        {
            sb.AppendLine($"    -- {thread.Description}");
        }
        sb.AppendLine("    -- Thread entry point. Add quest logic here as needed.");
        if (!string.IsNullOrWhiteSpace(thread.ExitStateName))
        {
            string exitValue = thread.ExitStateValue ? "true" : "false";
            sb.AppendLine($"    -- Exits when state '{thread.ExitStateName}' is {exitValue}");
        }
        sb.AppendLine("    while true do");
        if (!string.IsNullOrWhiteSpace(thread.ExitStateName))
        {
            string exitValue = thread.ExitStateValue ? "true" : "false";
            sb.AppendLine($"        if Quest:GetStateBool(\"{Escape(thread.ExitStateName)}\") == {exitValue} then break end");
        }
        double interval = thread.IntervalSeconds;
        if (interval <= 0)
        {
            interval = 0.5;
        }
        sb.AppendLine($"        Quest:Pause({interval.ToString(CultureInfo.InvariantCulture)})");
        sb.AppendLine("        if not Quest:NewScriptFrame() then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    // GenerateCompleteQuestFunction has been removed - completion logic is now inlined
    // in MonitorQuestCompletion thread to preserve PActiveThread context

    private void GenerateContainerSpawn(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine();
        sb.AppendLine("    -- Spawn reward container");

        // Generate spawn code based on location type
        switch (container.SpawnLocation)
        {
            case ContainerSpawnLocation.NearMarker:
                sb.AppendLine($"    local marker = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine("    local containerPos");
                sb.AppendLine("    if marker ~= nil then");
                sb.AppendLine("        containerPos = marker:GetPos()");
                sb.AppendLine("    else");
                sb.AppendLine("        local hero = Quest:GetHero()");
                sb.AppendLine("        containerPos = hero:GetPos()");
                sb.AppendLine("    end");
                break;

            case ContainerSpawnLocation.NearEntity:
                sb.AppendLine($"    local entity = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine("    local containerPos");
                sb.AppendLine("    if entity ~= nil then");
                sb.AppendLine("        containerPos = entity:GetPos()");
                sb.AppendLine("    else");
                sb.AppendLine("        local hero = Quest:GetHero()");
                sb.AppendLine("        containerPos = hero:GetPos()");
                sb.AppendLine("    end");
                break;

            case ContainerSpawnLocation.FixedPosition:
                string x = container.X.ToString(CultureInfo.InvariantCulture);
                string y = container.Y.ToString(CultureInfo.InvariantCulture);
                string z = container.Z.ToString(CultureInfo.InvariantCulture);
                sb.AppendLine($"    local containerPos = {{x={x}, y={y}, z={z}}}");
                break;
        }

        sb.AppendLine($"    local container = Quest:CreateObject(\"{container.ContainerDefName}\", containerPos, \"{container.ContainerScriptName}\")");
        sb.AppendLine("    if container ~= nil then");

        // Add items to container
        foreach (string item in container.Items)
        {
            sb.AppendLine($"        Quest:AddItemToContainer(container, \"{item}\")");
        }

        // Highlight container if configured
        if (container.HighlightContainer)
        {
            sb.AppendLine("        Quest:SetThingHasInformation(container, true)");
        }

        sb.AppendLine("    end");
        sb.AppendLine("    Quest:Pause(0.1)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
    }

    private void GenerateContainerReward(StringBuilder sb, QuestProject quest)
    {
        GenerateTraditionalContainerReward(sb, quest);
    }

    /// <summary>
    /// Generates traditional container-based rewards using container APIs.
    /// Only works with chest-like objects.
    /// </summary>
    private void GenerateTraditionalContainerReward(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine();
        sb.AppendLine("            -- Container reward: Spawn and populate container");
        sb.AppendLine("            Quest:Log(\"Attempting to spawn container...\")");

        // Generate spawn position code
        GenerateContainerSpawnPosition(sb, container, "            ");

        // Spawn the container
        sb.AppendLine($"            Quest:Log(\"Creating container: {container.ContainerDefName} at position...\")");
        sb.AppendLine($"            local container = Quest:CreateObject(\"{container.ContainerDefName}\", containerPos, \"{container.ContainerScriptName}\")");
        sb.AppendLine("            Quest:Log(\"CreateObject returned: \" .. tostring(container))");
        sb.AppendLine("            if container ~= nil then");
        sb.AppendLine("                Quest:Log(\"Container spawned successfully!\")");

        // CRITICAL: Make the container targetable/interactive
        sb.AppendLine("                Quest:EntitySetTargetable(container, true)");
        sb.AppendLine("                Quest:Log(\"Container set as targetable\")");

        if (container.AutoGiveOnComplete)
        {
            // Give items directly to hero (more reliable than GiveHeroItemsFromContainer)
            foreach (string item in container.Items)
            {
                sb.AppendLine($"                Quest:GiveHeroObject(\"{item}\", 1)");
            }
        }
        else
        {
            // Manual opening mode: Entity script handles giving items when hero interacts
            // The container was spawned with a script name that has a bound entity script
            // which will detect interaction via Me:MsgIsUsedByHero() and give all items
            sb.AppendLine("                -- Container uses entity script for multi-item rewards on manual open");

            // Highlight the container for player to find
            if (container.HighlightContainer)
            {
                sb.AppendLine("                Quest:SetThingHasInformation(container, true)");
            }
        }

        sb.AppendLine("            else");
        sb.AppendLine("                Quest:Log(\"WARNING: Failed to spawn container!\")");
        sb.AppendLine("            end");
    }

    /// <summary>
    /// Generates the spawn position code for containers/objects
    /// </summary>
    private void GenerateContainerSpawnPosition(StringBuilder sb, ContainerReward container, string indent)
    {
        switch (container.SpawnLocation)
        {
            case ContainerSpawnLocation.NearMarker:
                sb.AppendLine($"{indent}local marker = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine($"{indent}local containerPos");
                sb.AppendLine($"{indent}if marker ~= nil then");
                sb.AppendLine($"{indent}    containerPos = marker:GetPos()");
                sb.AppendLine($"{indent}else");
                sb.AppendLine($"{indent}    local hero = Quest:GetHero()");
                sb.AppendLine($"{indent}    containerPos = hero:GetPos()");
                sb.AppendLine($"{indent}end");
                break;

            case ContainerSpawnLocation.NearEntity:
                sb.AppendLine($"{indent}local entity = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine($"{indent}local containerPos");
                sb.AppendLine($"{indent}if entity ~= nil then");
                sb.AppendLine($"{indent}    containerPos = entity:GetPos()");
                sb.AppendLine($"{indent}else");
                sb.AppendLine($"{indent}    local hero = Quest:GetHero()");
                sb.AppendLine($"{indent}    containerPos = hero:GetPos()");
                sb.AppendLine($"{indent}end");
                break;

            case ContainerSpawnLocation.FixedPosition:
                string x = container.X.ToString(CultureInfo.InvariantCulture);
                string y = container.Y.ToString(CultureInfo.InvariantCulture);
                string z = container.Z.ToString(CultureInfo.InvariantCulture);
                sb.AppendLine($"{indent}local containerPos = {{x={x}, y={y}, z={z}}}");
                break;
        }
    }

    /// <summary>
    /// Generates automatic behavior for object entities with rewards.
    /// This creates a loop that waits for the hero to interact with the object,
    /// then gives the configured rewards.
    /// </summary>
    private void GenerateObjectRewardBehavior(StringBuilder sb, QuestEntity entity)
    {
        var reward = entity.ObjectReward!;
        string stateVar = $"{entity.ScriptName}_opened";

        sb.AppendLine("    -- Auto-generated reward behavior for object");
        sb.AppendLine("    -- This object gives rewards when interacted with by the hero");
        sb.AppendLine();

        if (reward.OneTimeOnly)
        {
            sb.AppendLine($"    local alreadyOpened = Quest:GetStateBool(\"{stateVar}\")");
            sb.AppendLine("    if alreadyOpened then");
            sb.AppendLine($"        Quest:Log(\"{entity.ScriptName}: Already opened, skipping reward behavior\")");
            sb.AppendLine("        return");
            sb.AppendLine("    end");
            sb.AppendLine();
        }

        sb.AppendLine("    -- Make object interactive");
        sb.AppendLine("    Quest:EntitySetTargetable(Me, true)");
        sb.AppendLine("    Quest:SetThingHasInformation(Me, true)");
        sb.AppendLine();
        sb.AppendLine("    -- Wait for hero interaction");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Me:MsgIsUsedByHero() then");
        sb.AppendLine($"            Quest:Log(\"{entity.ScriptName}: Hero interacted with object, giving rewards\")");
        sb.AppendLine();

        // Give gold
        if (reward.Gold > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroGold({reward.Gold})");
        }

        // Give experience
        if (reward.Experience > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroExperience({reward.Experience})");
        }

        // Give items
        foreach (string item in reward.Items)
        {
            sb.AppendLine($"            Quest:GiveHeroObject(\"{item}\", 1)");
        }

        // Show message
        if (reward.ShowMessage)
        {
            if (!string.IsNullOrWhiteSpace(reward.CustomMessage))
            {
                sb.AppendLine($"            Quest:ShowMessage(\"{Escape(reward.CustomMessage)}\", 3.0)");
            }
            else
            {
                // Build default message
                var messageParts = new List<string>();
                if (reward.Gold > 0) messageParts.Add($"{reward.Gold} gold");
                if (reward.Experience > 0) messageParts.Add($"{reward.Experience} XP");
                if (reward.Items.Count > 0) messageParts.Add($"{reward.Items.Count} item(s)");
                string defaultMessage = "Received: " + string.Join(", ", messageParts);
                sb.AppendLine($"            Quest:ShowMessage(\"{defaultMessage}\", 3.0)");
            }
        }

        // Mark as opened for one-time only objects
        if (reward.OneTimeOnly)
        {
            sb.AppendLine();
            sb.AppendLine($"            Quest:SetStateBool(\"{stateVar}\", true)");
        }

        // Destroy object if configured
        if (reward.DestroyAfterReward)
        {
            sb.AppendLine();
            sb.AppendLine("            -- Destroy the object after giving rewards");
            sb.AppendLine("            Quest:SetThingAsKilled(Me)");
            sb.AppendLine("            break");
        }
        else if (reward.OneTimeOnly)
        {
            sb.AppendLine();
            sb.AppendLine("            -- Remove highlight since object was already used");
            sb.AppendLine("            Quest:ClearThingHasInformation(Me)");
            sb.AppendLine("            break");
        }

        sb.AppendLine("        end");
        sb.AppendLine();
        sb.AppendLine("        if Me:IsNull() then break end");
        sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
        sb.AppendLine("    end");
    }

    private (int X, int Y) GetWorldMapOffset(QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "";
        return WorldMapCoordinateService.GetMapOffsetForQuest(primaryRegion, quest.Entities);
    }

    /// <summary>
    /// Builds the description text for the quest start screen.
    /// Combines the quest description with reward information since the game API
    /// doesn't have separate methods for setting experience rewards on the start screen.
    /// </summary>
    private string BuildStartScreenDescription(QuestProject quest)
    {
        var parts = new List<string>();

        // Add the quest description if present
        if (!string.IsNullOrWhiteSpace(quest.Description))
        {
            parts.Add(quest.Description.Trim());
        }

        // Build rewards summary if any rewards are configured
        var rewardParts = new List<string>();
        if (quest.Rewards.Gold > 0)
        {
            rewardParts.Add($"{quest.Rewards.Gold} Gold");
        }
        if (quest.Rewards.Experience > 0)
        {
            rewardParts.Add($"{quest.Rewards.Experience} XP");
        }
        if (quest.Rewards.Renown > 0)
        {
            rewardParts.Add($"{quest.Rewards.Renown} Renown");
        }
        if (quest.Rewards.Items.Count > 0)
        {
            rewardParts.Add($"{quest.Rewards.Items.Count} item(s)");
        }

        // Add rewards line if there are any
        if (rewardParts.Count > 0)
        {
            string rewardsLine = "Rewards: " + string.Join(", ", rewardParts);
            parts.Add(rewardsLine);
        }

        return string.Join("\\n\\n", parts);
    }

    private string RenderStateInit(QuestState state)
    {
        string value = state.DefaultValue?.ToString() ?? GetDefaultForType(state.Type);
        
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:SetStateBool(\"{state.Name}\", {value.ToLowerInvariant()})",
            "int" => $"    Quest:SetStateInt(\"{state.Name}\", {value})",
            "float" => $"    Quest:SetStateString(\"{state.Name}\", \"{value}\")",
            "string" => $"    Quest:SetStateString(\"{state.Name}\", \"{value}\")",
            _ => $"    Quest:SetStateBool(\"{state.Name}\", false) -- Unknown type: {state.Type}"
        };
    }

    private string RenderStatePersist(QuestState state)
    {
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    local {state.Name}_value = Quest:GetStateBool(\"{state.Name}\")\n" +
                      $"    {state.Name}_value = Quest:PersistTransferBool(context, \"{state.Name}\", {state.Name}_value)\n" +
                      $"    Quest:SetStateBool(\"{state.Name}\", {state.Name}_value)\n",
            "int" => $"    local {state.Name}_value = Quest:GetStateInt(\"{state.Name}\")\n" +
                     $"    {state.Name}_value = Quest:PersistTransferInt(context, \"{state.Name}\", {state.Name}_value)\n" +
                     $"    Quest:SetStateInt(\"{state.Name}\", {state.Name}_value)\n",
            "float" => $"    local {state.Name}_value = Quest:GetStateString(\"{state.Name}\")\n" +
                       $"    {state.Name}_value = Quest:PersistTransferString(context, \"{state.Name}\", {state.Name}_value)\n" +
                       $"    Quest:SetStateString(\"{state.Name}\", {state.Name}_value)\n",
            "string" => $"    local {state.Name}_value = Quest:GetStateString(\"{state.Name}\")\n" +
                        $"    {state.Name}_value = Quest:PersistTransferString(context, \"{state.Name}\", {state.Name}_value)\n" +
                        $"    Quest:SetStateString(\"{state.Name}\", {state.Name}_value)\n",
            _ => $"    local {state.Name}_value = Quest:GetStateBool(\"{state.Name}\")\n" +
                 $"    {state.Name}_value = Quest:PersistTransferBool(context, \"{state.Name}\", {state.Name}_value)\n" +
                 $"    Quest:SetStateBool(\"{state.Name}\", {state.Name}_value)\n"
        };
    }

    private string GenerateQuestLuaEntry(QuestProject quest)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    {quest.Name} = {{");
        sb.AppendLine($"        name = \"{quest.Name}\",");
        sb.AppendLine($"        file = \"{quest.Name}/{quest.Name}\",");
        sb.AppendLine($"        id = {quest.Id},");
        sb.AppendLine();
        sb.AppendLine("        entity_scripts = {");

        int entityId = quest.Id + 1;
        foreach (QuestEntity entity in quest.Entities)
        {
            sb.AppendLine($"            {{ name = \"{entity.ScriptName}\", file = \"{quest.Name}/Entities/{entity.ScriptName}\", id = {entityId} }},");
            entityId++;
        }

        // Add container entity script if needed (for manual-opening containers)
        if (NeedsContainerEntityScript(quest))
        {
            var container = quest.Rewards.Container!;
            sb.AppendLine($"            {{ name = \"{container.ContainerScriptName}\", file = \"{quest.Name}/Entities/{container.ContainerScriptName}\", id = {entityId} }},");
        }

        sb.AppendLine("        }");
        sb.Append("    },");

        return sb.ToString();
    }

    private static string GetDefaultForType(string type)
    {
        return type.ToLowerInvariant() switch
        {
            "bool" => "false",
            "int" => "0",
            "float" => "0.0",
            "string" => "",
            _ => "false"
        };
    }

    public string GenerateBehaviorCode(QuestEntity entity, string questName, int indent = 2)
    {
        if (entity.Nodes.Count == 0)
        {
            return GenerateIndent(indent) + "-- No behavior nodes defined\n";
        }

        StringBuilder sb = new StringBuilder();

        // Find all trigger nodes (entry points)
        var triggerNodes = entity.Nodes.Where(n => n.Category == "trigger").ToList();

        if (triggerNodes.Count == 0)
        {
            sb.AppendLine(GenerateIndent(indent) + "-- No trigger nodes found");
            return sb.ToString();
        }

        // Generate code for each trigger
        foreach (var trigger in triggerNodes)
        {
            sb.Append(GenerateNodeCode(trigger, entity, questName, indent));
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generates event function definitions from defineEvent nodes.
    /// These functions need to be defined BEFORE the main behavior loop so they
    /// can be called by callEvent nodes inside the loop.
    /// </summary>
    public string GenerateEventDefinitions(QuestEntity entity, string questName, int indent = 1)
    {
        // Find all defineEvent nodes
        var eventNodes = entity.Nodes.Where(n => n.Type == "defineEvent").ToList();

        if (eventNodes.Count == 0)
        {
            return string.Empty;
        }

        StringBuilder sb = new StringBuilder();

        foreach (var eventNode in eventNodes)
        {
            // Get the event name from config
            string eventName = "MyCustomEvent";
            if (eventNode.Config.TryGetValue("eventName", out object? value) && value != null)
            {
                eventName = value.ToString() ?? "MyCustomEvent";
            }

            // Generate the function definition
            sb.AppendLine(GenerateIndent(indent) + $"-- Event: {eventName}");
            sb.AppendLine(GenerateIndent(indent) + $"local function Event_{eventName}()");

            // Generate code for child nodes (the event body)
            var connections = GetExecConnections(eventNode, entity);
            if (connections.Count > 0)
            {
                foreach (var conn in connections)
                {
                    var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                    if (childNode != null)
                    {
                        sb.Append(GenerateNodeCode(childNode, entity, questName, indent + 1));
                    }
                }
            }
            else
            {
                sb.AppendLine(GenerateIndent(indent + 1) + "-- Event body (add child nodes)");
            }

            sb.AppendLine(GenerateIndent(indent) + "end");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private void AppendEntityVariableDeclarations(StringBuilder sb, QuestEntity entity, int indent)
    {
        if (entity.Variables == null || entity.Variables.Count == 0)
        {
            return;
        }

        sb.AppendLine();
        sb.AppendLine($"{GenerateIndent(indent)}-- Entity-local variables");

        foreach (var variable in entity.Variables)
        {
            string luaName = BuildLuaVariableName(variable.Name);
            string defaultValue = FormatLuaLiteral(variable.Type, variable.DefaultValue);
            sb.AppendLine($"{GenerateIndent(indent)}local {luaName} = {defaultValue}");
        }

        sb.AppendLine();
    }

    private NodeDefinition? TryBuildVariableNodeDefinition(BehaviorNode node, QuestEntity entity)
    {
        const string getPrefix = "var_get_";
        const string setPrefix = "var_set_";

        if (!node.Type.StartsWith(getPrefix, StringComparison.OrdinalIgnoreCase) &&
            !node.Type.StartsWith(setPrefix, StringComparison.OrdinalIgnoreCase))
        {
            return null;
        }

        string variableName = node.Type.StartsWith(getPrefix, StringComparison.OrdinalIgnoreCase)
            ? node.Type.Substring(getPrefix.Length)
            : node.Type.Substring(setPrefix.Length);

        var variable = entity.Variables.FirstOrDefault(v =>
            v.Name.Equals(variableName, StringComparison.OrdinalIgnoreCase));

        string variableType = variable?.Type ?? "String";
        string luaName = BuildLuaVariableName(variableName);
        string nodeType = MapVariableTypeToNodeType(variableType);

        if (node.Type.StartsWith(getPrefix, StringComparison.OrdinalIgnoreCase))
        {
            return new NodeDefinition
            {
                Type = node.Type,
                Label = $"Get {variableName}",
                Category = "variable",
                Icon = "",
                IsAdvanced = false,
                Description = $"Gets the value of variable '{variableName}'",
                ValueType = variableType,
                Properties = new List<NodeProperty>(),
                CodeTemplate = $"local {luaName}_value = {luaName}\n{{CHILDREN}}"
            };
        }

        bool isString = nodeType == "string";
        string valueTemplate = isString ? "\"{value}\"" : "{value}";

        return new NodeDefinition
        {
            Type = node.Type,
            Label = $"Set {variableName}",
            Category = "variable",
            Icon = "",
            IsAdvanced = false,
            Description = $"Sets the value of variable '{variableName}'",
            ValueType = variableType,
            Properties = new List<NodeProperty>
            {
                new() { Name = "value", Type = nodeType, Label = "Value", DefaultValue = variable?.DefaultValue ?? string.Empty }
            },
            CodeTemplate = $"{luaName} = {valueTemplate}\n{{CHILDREN}}"
        };
    }

    private static string MapVariableTypeToNodeType(string variableType)
    {
        return variableType switch
        {
            "Boolean" => "bool",
            "Integer" => "int",
            "Float" => "float",
            "String" => "string",
            _ => "string"
        };
    }

    private static string BuildLuaVariableName(string variableName)
    {
        if (string.IsNullOrWhiteSpace(variableName))
        {
            return "var_unnamed";
        }

        var chars = variableName.Select(c =>
        {
            if (c <= 127 && (char.IsLetterOrDigit(c) || c == '_'))
            {
                return c;
            }

            return '_';
        }).ToArray();

        string normalized = new string(chars);
        if (char.IsDigit(normalized[0]))
        {
            normalized = "_" + normalized;
        }

        return "var_" + normalized;
    }

    private static string FormatLuaLiteral(string variableType, string? value)
    {
        string type = variableType ?? "String";
        string rawValue = value ?? string.Empty;

        return type switch
        {
            "Boolean" => bool.TryParse(rawValue, out bool b) ? b.ToString().ToLowerInvariant() : "false",
            "Integer" => int.TryParse(rawValue, NumberStyles.Integer, CultureInfo.InvariantCulture, out int i) ? i.ToString(CultureInfo.InvariantCulture) : "0",
            "Float" => double.TryParse(rawValue, NumberStyles.Float, CultureInfo.InvariantCulture, out double d) ? d.ToString(CultureInfo.InvariantCulture) : "0.0",
            "String" => $"\"{Escape(rawValue)}\"",
            _ => $"\"{Escape(rawValue)}\""
        };
    }

    private static string GenerateIndent(int level)
    {
        return new string(' ', level * 4);
    }

    private static string ReplacePlaceholderWithVariable(string code, string propName, string luaName)
    {
        string quotedPlaceholder = $"\"{{{propName}}}\"";
        if (code.Contains(quotedPlaceholder))
        {
            code = code.Replace(quotedPlaceholder, luaName);
        }

        string placeholder = "{" + propName + "}";
        return code.Replace(placeholder, luaName);
    }

    private static bool TryResolveVariableReference(QuestEntity entity, string value, out string luaName)
    {
        luaName = string.Empty;
        if (string.IsNullOrWhiteSpace(value) || value[0] != '$')
        {
            return false;
        }

        string variableName = value.Substring(1).Trim();
        if (string.IsNullOrWhiteSpace(variableName))
        {
            return false;
        }

        if (entity.Variables == null)
        {
            return false;
        }

        bool exists = entity.Variables.Any(v =>
            v.Name.Equals(variableName, StringComparison.OrdinalIgnoreCase));

        if (!exists)
        {
            return false;
        }

        luaName = BuildLuaVariableName(variableName);
        return true;
    }

    private List<NodeConnection> GetExecConnections(BehaviorNode node, QuestEntity entity)
    {
        var nodeDef = NodeDefinitions.GetAllNodes().FirstOrDefault(n => n.Type == node.Type)
            ?? TryBuildVariableNodeDefinition(node, entity);

        if (nodeDef == null)
        {
            return new List<NodeConnection>();
        }

        return entity.Connections
            .Where(c => c.FromNodeId == node.Id && IsExecPort(nodeDef, c.FromPort))
            .ToList();
    }

    private static bool IsExecPort(NodeDefinition nodeDef, string? port)
    {
        if (nodeDef.Category == "variable")
        {
            return false;
        }

        if (string.IsNullOrWhiteSpace(port))
        {
            return true;
        }

        if (string.Equals(port, "", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(port, "Exec", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(port, "Output", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (nodeDef.BranchLabels != null &&
            nodeDef.BranchLabels.Any(label => label.Equals(port, StringComparison.OrdinalIgnoreCase)))
        {
            return true;
        }

        return false;
    }

    /// <summary>
    /// Generates Lua code for a behavior node and its children.
    /// Handles both structured nodes (triggers, conditions) and linear action sequences.
    /// </summary>
    private string GenerateNodeCode(BehaviorNode node, QuestEntity entity, string questName, int indent)
    {
        if (string.Equals(node.Type, "randomChoice", StringComparison.OrdinalIgnoreCase))
        {
            return GenerateRandomChoiceNode(node, entity, questName, indent);
        }

        if (string.Equals(node.Type, "parallel", StringComparison.OrdinalIgnoreCase))
        {
            return GenerateParallelNode(node, entity, questName, indent);
        }

        var nodeDef = NodeDefinitions.GetAllNodes().FirstOrDefault(n => n.Type == node.Type);
        if (nodeDef == null)
        {
            nodeDef = TryBuildVariableNodeDefinition(node, entity);
            if (nodeDef == null)
            {
                return GenerateIndent(indent) + $"-- Unknown node type: {node.Type}\n";
            }
        }

        StringBuilder sb = new StringBuilder();

        // Check if this is a linear action (non-branching action node)
        bool isLinearAction = nodeDef.Category == "action" && !nodeDef.HasBranching;

        if (isLinearAction)
        {
            // For linear actions, emit THIS node's code at current indent,
            // then emit children at SAME indent (not nested)
            string code = ProcessNodeTemplate(nodeDef, node, entity, questName);
            
            // Remove {CHILDREN} - we handle sequencing explicitly
            code = code.Replace("{CHILDREN}", "").TrimEnd();

            // Emit this node's code lines
            foreach (string line in code.Split('\n'))
            {
                if (!string.IsNullOrWhiteSpace(line))
                {
                    sb.AppendLine(GenerateIndent(indent) + line);
                }
            }

            // Process children at SAME indent level (linear sequence, not nested)
            var connections = GetExecConnections(node, entity);
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    sb.Append(GenerateNodeCode(childNode, entity, questName, indent)); // Same indent!
                }
            }
        }
        else
        {
            // For structured nodes (triggers, conditions, flow), use template substitution
            sb.Append(GenerateStructuredNode(node, nodeDef, entity, questName, indent));
        }

        return sb.ToString();
    }

    private string GenerateParallelNode(BehaviorNode node, QuestEntity entity, string questName, int indent)
    {
        var connections = GetExecConnections(node, entity);
        var childNodes = connections
            .Select(c => entity.Nodes.FirstOrDefault(n => n.Id == c.ToNodeId))
            .Where(n => n != null)
            .Distinct()
            .ToList();

        if (childNodes.Count == 0)
        {
            return GenerateIndent(indent) + "-- Parallel has no connected children\n";
        }

        // Parallel execution is not supported in entity scripts; execute sequentially.
        StringBuilder sb = new StringBuilder();
        sb.AppendLine(GenerateIndent(indent) + "-- Parallel execution is not supported in entity scripts; running sequentially");

        foreach (var child in childNodes)
        {
            sb.Append(GenerateNodeCode(child!, entity, questName, indent));
        }

        return sb.ToString();
    }

    private string GenerateRandomChoiceNode(BehaviorNode node, QuestEntity entity, string questName, int indent)
    {
        var connections = GetExecConnections(node, entity);
        var childNodes = connections
            .Select(c => entity.Nodes.FirstOrDefault(n => n.Id == c.ToNodeId))
            .Where(n => n != null)
            .Distinct()
            .ToList();

        if (childNodes.Count == 0)
        {
            return GenerateIndent(indent) + "-- Random choice has no connected children\n";
        }

        // Order children by position for deterministic output
        childNodes.Sort((a, b) =>
        {
            int xCompare = a!.X.CompareTo(b!.X);
            return xCompare != 0 ? xCompare : a.Y.CompareTo(b!.Y);
        });

        int choiceCount = childNodes.Count;
        if (node.Config.TryGetValue("maxChoice", out object? maxValue) &&
            int.TryParse(maxValue?.ToString(), out int configuredMax) &&
            configuredMax > 0)
        {
            choiceCount = Math.Min(choiceCount, configuredMax);
        }

        StringBuilder sb = new StringBuilder();
        sb.AppendLine(GenerateIndent(indent) + $"-- Random choice (1 to {choiceCount})");
        sb.AppendLine(GenerateIndent(indent) + $"local randomChoice = math.random(1, {choiceCount})");

        for (int i = 0; i < choiceCount; i++)
        {
            string keyword = i == 0 ? "if" : "elseif";
            sb.AppendLine(GenerateIndent(indent) + $"{keyword} randomChoice == {i + 1} then");
            sb.Append(GenerateNodeCode(childNodes[i]!, entity, questName, indent + 1));
        }

        sb.AppendLine(GenerateIndent(indent) + "end");
        return sb.ToString();
    }

    /// <summary>
    /// Processes a node's template, replacing placeholders with config values.
    /// Text and string properties are escaped to prevent Lua syntax errors.
    /// </summary>
    private string ProcessNodeTemplate(NodeDefinition nodeDef, BehaviorNode node, QuestEntity entity, string questName)
    {
        string code = nodeDef.CodeTemplate;

        code = code.Replace("{QUEST_NAME}", Escape(questName));

        // Build a lookup of property types for escaping decisions
        var propertyTypes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                propertyTypes[propDef.Name] = propDef.Type;
            }
        }

        // Apply config values from the node (with proper escaping for text/string types)
        foreach (var prop in node.Config)
        {
            string placeholder = "{" + prop.Key + "}";
            string value = prop.Value?.ToString() ?? "";
            if (TryResolveVariableReference(entity, value, out string luaName))
            {
                code = ReplacePlaceholderWithVariable(code, prop.Key, luaName);
                continue;
            }

            // Escape text and string properties to prevent Lua syntax errors from quotes/special chars
            if (propertyTypes.TryGetValue(prop.Key, out string? propType) &&
                (propType == "text" || propType == "string"))
            {
                value = Escape(value);
            }

            code = code.Replace(placeholder, value);
        }

        // Apply default values for missing properties (with proper escaping)
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                string placeholder = "{" + propDef.Name + "}";
                if (code.Contains(placeholder))
                {
                    string defaultValue = propDef.DefaultValue?.ToString() ?? "";
                    if (TryResolveVariableReference(entity, defaultValue, out string luaName))
                    {
                        code = ReplacePlaceholderWithVariable(code, propDef.Name, luaName);
                        continue;
                    }

                    // Escape text and string default values
                    if (propDef.Type == "text" || propDef.Type == "string")
                    {
                        defaultValue = Escape(defaultValue);
                    }

                    code = code.Replace(placeholder, defaultValue);
                }
            }
        }

        return code;
    }

    /// <summary>
    /// Generates code for structured nodes (triggers, conditions, flow control).
    /// Children are indented inside the control structure.
    /// </summary>
    private string GenerateStructuredNode(BehaviorNode node, NodeDefinition nodeDef, QuestEntity entity, string questName, int indent)
    {
        StringBuilder sb = new StringBuilder();
        string code = ProcessNodeTemplate(nodeDef, node, entity, questName);

        // Handle children (connected nodes)
        var connections = GetExecConnections(node, entity);
        
        if (nodeDef.HasBranching)
        {
            // Branching nodes (if/else) - children go into specific branches at indent+1
            var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
            var branchCode = new Dictionary<string, StringBuilder>();

            foreach (var label in branchLabels)
            {
                branchCode[label] = new StringBuilder();
            }

            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null && !string.IsNullOrEmpty(conn.FromPort))
                {
                    string childCode = GenerateNodeCode(childNode, entity, questName, indent + 1);
                    if (branchCode.ContainsKey(conn.FromPort))
                    {
                        branchCode[conn.FromPort].Append(childCode);
                    }
                }
            }

            foreach (var label in branchLabels)
            {
                string placeholder = "{" + label + "}";
                string placeholderUpper = "{" + label.ToUpper() + "}";
                string branchContent = branchCode[label].Length > 0
                    ? branchCode[label].ToString().TrimEnd('\n')
                    : GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";

                code = code.Replace(placeholder, branchContent);
                code = code.Replace(placeholderUpper, branchContent);
            }
        }
        else if (connections.Count > 0)
        {
            // Non-branching structured node (trigger) - children go inside at indent+1
            StringBuilder childrenCode = new StringBuilder();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    childrenCode.Append(GenerateNodeCode(childNode, entity, questName, indent + 1));
                }
            }
            code = code.Replace("{CHILDREN}", childrenCode.ToString().TrimEnd('\n'));
        }
        else
        {
            // No connections - clear placeholders
            code = code.Replace("{CHILDREN}", "");
            
            if (nodeDef.HasBranching)
            {
                var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
                foreach (var label in branchLabels)
                {
                    string placeholder = "{" + label + "}";
                    string placeholderUpper = "{" + label.ToUpper() + "}";
                    string comment = GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";
                    code = code.Replace(placeholder, comment);
                    code = code.Replace(placeholderUpper, comment);
                }
            }
        }

        // Emit code with proper indentation
        // Lines that are already indented (from child substitution) are emitted as-is
        foreach (string line in code.Split('\n'))
        {
            if (string.IsNullOrWhiteSpace(line))
            {
                continue;
            }
            
            // Check if line is already indented (from child code substitution)
            bool alreadyIndented = line.Length > 0 && (line[0] == ' ' || line[0] == '\t');
            
            if (alreadyIndented)
            {
                sb.AppendLine(line);
            }
            else
            {
                sb.AppendLine(GenerateIndent(indent) + line);
            }
        }

        return sb.ToString();
    }

    private static string Escape(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;

        return text
            .Replace("\\", "\\\\")  // Must be first to avoid double-escaping
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t")
            .Replace("\0", "");     // Remove null characters
    }
}
