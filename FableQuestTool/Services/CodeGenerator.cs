using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using FableQuestTool.Data;
using FableQuestTool.Models;

namespace FableQuestTool.Services;

public sealed class CodeGenerator
{
    private Dictionary<string, string> exposedVariableTypes = new(StringComparer.OrdinalIgnoreCase);
    private bool needsActionQueue;
    private static readonly HashSet<string> ActionQueueNodeTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "highlightQuestTarget",
        "clearQuestTargetHighlight",
        "showMinimapMarker",
        "hideMinimapMarker",
        "highlightQuestTargetByName",
        "clearQuestTargetHighlightByName",
        "showMinimapMarkerByName",
        "hideMinimapMarkerByName"
    };

    // Set of node types that are cinematic/async and need pauses after them
    private static readonly HashSet<string> CinematicNodeTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "letterbox", "letterboxOff", "screenFadeOut", "screenFadeIn", "overrideMusic", 
        "stopMusicOverride", "cameraOrbitEntity", "cameraLookAtEntity", "cameraResetToHero",
        "cameraUseCameraPoint", "cameraConversation", "cameraCircleAroundThing",
        "startConversation", "addConversationLine", "endConversation",
        "radialBlur", "radialBlurOff", "colorFilter", "colorFilterOff",
        "playMovie", "startMovieSequence", "endMovieSequence"
    };

    public string GenerateQuestScript(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {quest.Name}.lua");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("Quest = nil");
        sb.AppendLine();

        exposedVariableTypes = BuildExposedVariableTypeMap(quest);
        needsActionQueue = NeedsActionQueue(quest);

        // Generate Init function
        GenerateInitFunction(sb, quest);

        // Generate Main function
        GenerateMainFunction(sb, quest);

        // Generate OnPersist function
        GenerateOnPersistFunction(sb, quest);

        // Generate EntitySpawner thread if needed
        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) || 
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            GenerateEntitySpawnerThread(sb, quest);
        }

        // Generate MonitorQuestCompletion thread
        GenerateMonitorQuestCompletion(sb, quest);

        if (needsActionQueue)
        {
            GenerateQuestActionQueueHelper(sb);
            GenerateQuestActionQueueThread(sb);
        }

        // Generate user-defined threads
        foreach (QuestThread thread in quest.Threads)
        {
            GenerateUserThread(sb, thread);
        }

        // CompleteQuest logic is now inlined in MonitorQuestCompletion thread to preserve thread context

        return sb.ToString();
    }

    public string GenerateEntityScript(QuestProject quest, QuestEntity entity)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {entity.ScriptName}.lua");
        sb.AppendLine($"-- Entity script for {quest.Name}");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("local Quest = nil");
        sb.AppendLine("local Me = nil");
        sb.AppendLine();
        sb.AppendLine("function Init(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Init called\")");

        // Entity control settings
        if (entity.MakeBehavioral)
        {
            sb.AppendLine("    Me:MakeBehavioral()");
        }
        // Always use AcquireControl if enabled, as it works with SpeakAndWait
        // TakeExclusiveControl does NOT work with SpeakAndWait
        if (entity.AcquireControl)
        {
            sb.AppendLine("    Me:AcquireControl()");
        }
        else if (entity.ExclusiveControl)
        {
            sb.AppendLine("    Me:TakeExclusiveControl()");
        }

        sb.AppendLine("end");
        sb.AppendLine();
        sb.AppendLine("function Main(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{entity.ScriptName}: Main started\")");
        sb.AppendLine("    local hero = Quest:GetHero()");

        // Entity properties
        if (entity.Invulnerable)
        {
            sb.AppendLine("    Quest:EntitySetAsDamageable(Me, false)");
        }
        if (entity.Unkillable)
        {
            sb.AppendLine("    Quest:EntitySetAsKillable(Me, false)");
        }
        if (entity.Persistent)
        {
            sb.AppendLine("    Quest:SetThingPersistent(Me, true)");
        }
        if (entity.KillOnLevelUnload)
        {
            sb.AppendLine("    Me:SetToKillOnLevelUnload(true)");
        }

        sb.AppendLine();

        // Check if this object entity has rewards configured
        bool hasObjectRewards = entity.EntityType == EntityType.Object &&
                               entity.ObjectReward != null &&
                               entity.ObjectReward.HasRewards;

        if (entity.Nodes.Count > 0)
        {
            sb.AppendLine("    -- Main behavior loop");
            sb.AppendLine("    while true do");

            // Generate code from node graph
            string behaviorCode = GenerateBehaviorCode(entity, quest.Name, 2);
            sb.Append(behaviorCode);

            sb.AppendLine();
            sb.AppendLine("        if Me:IsNull() then break end");
            // Frame check at END of loop only (like working MAssassinNPC example)
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }
        else if (hasObjectRewards)
        {
            // Object has rewards but no custom behavior nodes - auto-generate reward behavior
            GenerateObjectRewardBehavior(sb, entity);
        }
        else if (entity.AcquireControl || entity.ExclusiveControl)
        {
            // Entity has control but no behavior nodes - add minimal loop
            sb.AppendLine("    -- Minimal behavior loop (add behavior nodes for triggers and actions)");
            sb.AppendLine("    while true do");
            sb.AppendLine("        -- Add trigger nodes in the visual editor to respond to hero interactions");
            sb.AppendLine("        if Me:IsNull() then break end");
            sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
            sb.AppendLine("    end");
        }

        sb.AppendLine();
        sb.AppendLine("    Me:ReleaseControl()");
        sb.AppendLine("end");

        return sb.ToString();
    }

    /// <summary>
    /// Generates an entity script for a container that gives multiple items when manually opened.
    /// This is used for quest-level container rewards when AutoGiveOnComplete is disabled.
    /// </summary>
    public string GenerateContainerEntityScript(QuestProject quest, ContainerReward container)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"-- {container.ContainerScriptName}.lua");
        sb.AppendLine($"-- Container entity script for {quest.Name}");
        sb.AppendLine("-- Generated by FSE Quest Creator Pro");
        sb.AppendLine();
        sb.AppendLine("local Quest = nil");
        sb.AppendLine("local Me = nil");
        sb.AppendLine();
        sb.AppendLine("function Init(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{container.ContainerScriptName}: Init called\")");
        sb.AppendLine("    Me:AcquireControl()");
        sb.AppendLine("end");
        sb.AppendLine();
        sb.AppendLine("function Main(questObject, meObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Me = meObject");
        sb.AppendLine($"    Quest:Log(\"{container.ContainerScriptName}: Main started - waiting for hero interaction\")");
        sb.AppendLine();
        sb.AppendLine("    -- Make container interactive");
        sb.AppendLine("    Quest:EntitySetTargetable(Me, true)");
        sb.AppendLine();
        sb.AppendLine("    -- Wait for hero to interact with container");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Me:MsgIsUsedByHero() then");
        sb.AppendLine($"            Quest:Log(\"{container.ContainerScriptName}: Hero opened container - giving rewards!\")");
        sb.AppendLine();

        // Give all items
        sb.AppendLine("            -- Give all items to hero");
        foreach (string item in container.Items)
        {
            sb.AppendLine($"            Quest:GiveHeroObject(\"{item}\", 1)");
        }

        sb.AppendLine();
        sb.AppendLine("            -- Clear highlight");
        sb.AppendLine("            Quest:ClearThingHasInformation(Me)");
        sb.AppendLine();
        sb.AppendLine("            -- Container opened - exit loop");
        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine();
        sb.AppendLine("        if Me:IsNull() then break end");
        sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
        sb.AppendLine("    end");
        sb.AppendLine();
        sb.AppendLine("    Me:ReleaseControl()");
        sb.AppendLine("end");

        return sb.ToString();
    }

    /// <summary>
    /// Checks if this quest needs a container entity script (for manual-opening containers).
    /// </summary>
    public bool NeedsContainerEntityScript(QuestProject quest)
    {
        return quest.Rewards.Container != null &&
               quest.Rewards.Container.Items.Count > 0 &&
               !quest.Rewards.Container.AutoGiveOnComplete;
    }

    public string GenerateRegistrationSnippet(QuestProject quest)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("-- Add this entry inside the Quests table in quests.lua");
        sb.Append(GenerateQuestLuaEntry(quest));
        return sb.ToString();
    }

    private void GenerateInitFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Init(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Init phase started.\")");

        if (needsActionQueue)
        {
            sb.AppendLine("    Quest:SetStateInt(\"FQT_ActionCounter\", 0)");
            sb.AppendLine("    Quest:SetStateInt(\"FQT_ActionProcessed\", 0)");
            sb.AppendLine("    Quest:SetStateBool(\"FQT_StopActions\", false)");
            sb.AppendLine();
        }

        // Add quest regions
        foreach (string region in quest.Regions)
        {
            sb.AppendLine($"    Quest:AddQuestRegion(\"{quest.Name}\", \"{region}\")");
        }

        // Set world map offset
        var mapOffset = GetWorldMapOffset(quest);
        sb.AppendLine($"    Quest:SetQuestWorldMapOffset(\"{quest.Name}\", {mapOffset.X}, {mapOffset.Y})");

        // Initialize QuestCompleted state
        sb.AppendLine("    Quest:SetStateBool(\"QuestCompleted\", false)");

        // Initialize user-defined states
        foreach (QuestState state in quest.States)
        {
            sb.AppendLine(RenderStateInit(state));
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateMainFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function Main(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: Main() started.\")");
        sb.AppendLine();

        // Check if we need container entity binding (for manual-opening containers)
        bool needsContainerEntity = quest.Rewards.Container != null &&
                                    quest.Rewards.Container.Items.Count > 0 &&
                                    !quest.Rewards.Container.AutoGiveOnComplete;

        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";

        // Bind entity scripts
        if (quest.Entities.Count > 0 || needsContainerEntity)
        {
            sb.AppendLine("    -- Bind entity scripts");
            foreach (QuestEntity entity in quest.Entities)
            {
                sb.AppendLine($"    Quest:AddEntityBinding(\"{entity.ScriptName}\", \"{quest.Name}/Entities/{entity.ScriptName}\")");
            }

            // Add container entity binding if needed
            if (needsContainerEntity)
            {
                var container = quest.Rewards.Container!;
                sb.AppendLine($"    Quest:AddEntityBinding(\"{container.ContainerScriptName}\", \"{quest.Name}/Entities/{container.ContainerScriptName}\")");
            }

            sb.AppendLine("    Quest:FinalizeEntityBindings()");
            sb.AppendLine();
        }

        // Quest card configuration
        if (!string.IsNullOrWhiteSpace(quest.QuestCardObject))
        {
            sb.AppendLine("    -- Configure quest card");
            if (quest.IsGuildQuest)
            {
                sb.AppendLine($"    Quest:AddGuildQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }
            else if (quest.GiveCardDirectly)
            {
                sb.AppendLine($"    Quest:GiveQuestCardDirectly(\"{quest.QuestCardObject}\", \"{quest.Name}\", true)");
            }
            else
            {
                sb.AppendLine($"    Quest:AddQuestCard(\"{quest.QuestCardObject}\", \"{quest.Name}\", false, false)");
            }

            if (!string.IsNullOrWhiteSpace(quest.ObjectiveText))
            {
                string region1 = quest.ObjectiveRegion1 ?? quest.Regions.FirstOrDefault() ?? "";
                string region2 = quest.ObjectiveRegion2 ?? "";
                sb.AppendLine($"    Quest:SetQuestCardObjective(\"{quest.Name}\", \"{Escape(quest.ObjectiveText)}\", \"{region1}\", \"{region2}\")");
            }

            if (quest.Rewards.Gold > 0)
            {
                sb.AppendLine($"    Quest:SetQuestGoldReward(\"{quest.Name}\", {quest.Rewards.Gold})");
            }

            if (quest.Rewards.Renown > 0)
            {
                sb.AppendLine($"    Quest:SetQuestRenownReward(\"{quest.Name}\", {quest.Rewards.Renown})");
            }
            sb.AppendLine();
        }

        // Start threads
        sb.AppendLine("    -- Start quest threads");

        if (quest.Entities.Any(e => e.SpawnMethod != SpawnMethod.BindExisting) ||
            quest.Entities.Any(e => e.IsQuestTarget || e.ShowOnMinimap))
        {
            sb.AppendLine($"    Quest:CreateThread(\"EntitySpawner\", {{region=\"{primaryRegion}\"}})");
        }

        sb.AppendLine($"    Quest:CreateThread(\"MonitorQuestCompletion\", {{region=\"{primaryRegion}\"}})");

        if (needsActionQueue)
        {
            sb.AppendLine($"    Quest:CreateThread(\"ProcessQuestActions\", {{region=\"{primaryRegion}\"}})");
        }

        foreach (QuestThread thread in quest.Threads)
        {
            sb.AppendLine($"    Quest:CreateThread(\"{thread.FunctionName}\", {{region=\"{thread.Region}\"}})");
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateOnPersistFunction(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function OnPersist(questObject, context)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    Quest:PersistTransferBool(context, \"QuestCompleted\")");

        foreach (QuestState state in quest.States)
        {
            if (state.Persist)
            {
                sb.AppendLine(RenderStatePersist(state));
            }
        }

        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateEntitySpawnerThread(StringBuilder sb, QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "Oakvale";

        sb.AppendLine("function EntitySpawner(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine($"    -- Thread is region-bound to {primaryRegion} - FSE auto-waits for region load");
        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner executing (region is loaded).\")");
        sb.AppendLine();
        sb.AppendLine("    -- Brief pause to let game settle after region load");
        sb.AppendLine("    Quest:Pause(0.5)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
        sb.AppendLine();

        // Spawn entities
        var entitiesToSpawn = quest.Entities.Where(e => e.SpawnMethod != SpawnMethod.BindExisting).ToList();
        if (entitiesToSpawn.Count > 0)
        {
            sb.AppendLine("    -- Spawn entities");
            foreach (QuestEntity entity in entitiesToSpawn)
            {
                string spawnCode = GenerateEntitySpawnCode(entity);
                if (!string.IsNullOrWhiteSpace(spawnCode))
                {
                    sb.AppendLine(spawnCode);
                    sb.AppendLine();
                }
            }
        }

        // Set up quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("    -- Set up quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"    local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"    if {entity.ScriptName} ~= nil then");
                
                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"        Quest:SetThingHasInformation({entity.ScriptName}, true)");
                }
                
                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"        Quest:MiniMapAddMarker({entity.ScriptName}, \"{entity.ScriptName}\")");
                }
                
                sb.AppendLine("    end");
            }
            sb.AppendLine();
        }

        // Note: Container rewards are now spawned during quest completion, not here
        // This prevents issues with containers despawning before quest completes

        sb.AppendLine($"    Quest:Log(\"{quest.Name}: EntitySpawner completed.\")");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private string GenerateEntitySpawnCode(QuestEntity entity)
    {
        // Use CreateObject for Object entities, CreateCreature for others
        if (entity.EntityType == EntityType.Object)
        {
            return entity.SpawnMethod switch
            {
                SpawnMethod.AtMarker => GenerateCreateObjectAtMarker(entity),
                SpawnMethod.AtPosition => GenerateCreateObjectAtPosition(entity),
                SpawnMethod.CreateCreature => GenerateCreateObjectAtMarker(entity),
                SpawnMethod.OnEntity => GenerateCreateObjectOnEntity(entity),
                _ => string.Empty
            };
        }

        return entity.SpawnMethod switch
        {
            SpawnMethod.AtMarker => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.AtPosition => GenerateCreateCreatureAtPosition(entity),
            SpawnMethod.CreateCreature => GenerateCreateCreatureAtMarker(entity),
            SpawnMethod.OnEntity => GenerateCreateCreatureOnEntity(entity),
            _ => string.Empty
        };
    }

    private string GenerateCreateCreatureAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateCreature(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateCreatureOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local {entity.ScriptName} = Quest:CreateCreatureOnEntity(""{entity.DefName}"", targetEntity_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow entity to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectAtMarker(QuestEntity entity)
    {
        return $@"    local marker_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if marker_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = marker_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    else
        local hero = Quest:GetHero()
        local heroPos = hero:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", heroPos, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectAtPosition(QuestEntity entity)
    {
        string x = entity.SpawnX.ToString(CultureInfo.InvariantCulture);
        string y = entity.SpawnY.ToString(CultureInfo.InvariantCulture);
        string z = entity.SpawnZ.ToString(CultureInfo.InvariantCulture);

        return $@"    local pos_{entity.ScriptName} = {{x={x}, y={y}, z={z}}}
    local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private string GenerateCreateObjectOnEntity(QuestEntity entity)
    {
        return $@"    local targetEntity_{entity.ScriptName} = Quest:GetThingWithScriptName(""{entity.SpawnMarker}"")
    if targetEntity_{entity.ScriptName} ~= nil then
        local pos_{entity.ScriptName} = targetEntity_{entity.ScriptName}:GetPos()
        local {entity.ScriptName} = Quest:CreateObject(""{entity.DefName}"", pos_{entity.ScriptName}, ""{entity.ScriptName}"")
    end

    -- Brief pause to allow object to fully spawn
    Quest:Pause(0.1)
    if not Quest:NewScriptFrame() then return end";
    }

    private void GenerateMonitorQuestCompletion(StringBuilder sb, QuestProject quest)
    {
        sb.AppendLine("function MonitorQuestCompletion(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Quest:GetStateBool(\"QuestCompleted\") then");
        if (needsActionQueue)
        {
            sb.AppendLine("            Quest:SetStateBool(\"FQT_StopActions\", true)");
            sb.AppendLine("            Quest:Pause(0.1)");
            sb.AppendLine("            if not Quest:NewScriptFrame() then break end");
        }
        sb.AppendLine($"            Quest:Log(\"{quest.Name}: Quest completed, giving rewards...\")");
        sb.AppendLine();

        // Clear quest target highlighting
        var questTargets = quest.Entities.Where(e => e.IsQuestTarget || e.ShowOnMinimap).ToList();
        if (questTargets.Count > 0)
        {
            sb.AppendLine("            -- Clear quest target highlighting and minimap markers");
            foreach (QuestEntity entity in questTargets)
            {
                sb.AppendLine($"            local {entity.ScriptName} = Quest:GetThingWithScriptName(\"{entity.ScriptName}\")");
                sb.AppendLine($"            if {entity.ScriptName} ~= nil and not {entity.ScriptName}:IsNull() then");

                if (entity.IsQuestTarget)
                {
                    sb.AppendLine($"                Quest:ClearThingHasInformation({entity.ScriptName})");
                }

                if (entity.ShowOnMinimap)
                {
                    sb.AppendLine($"                Quest:MiniMapRemoveMarker({entity.ScriptName})");
                }

                sb.AppendLine("            end");
            }
            sb.AppendLine();
        }

        // Give rewards
        sb.AppendLine("            -- Give rewards");
        if (quest.Rewards.Gold > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroGold({quest.Rewards.Gold})");
        }
        if (quest.Rewards.Experience > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroExperience({quest.Rewards.Experience})");
        }
        if (quest.Rewards.Renown > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroRenownPoints({quest.Rewards.Renown})");
        }
        if (quest.Rewards.Morality != 0)
        {
            sb.AppendLine("            -- Give morality reward (engine uses 2000-point scale)");
            sb.AppendLine($"            Quest:GiveHeroMorality({FormatMoralityValue(quest.Rewards.Morality)} / 2000)");
        }

        if (quest.Rewards.Items.Count > 0)
        {
            foreach (string item in quest.Rewards.Items)
            {
                sb.AppendLine($"            Quest:GiveHeroObject(\"{item}\", 1)");
            }
        }

        // Container-based rewards (for multiple items)
        if (quest.Rewards.Container != null && quest.Rewards.Container.Items.Count > 0)
        {
            GenerateContainerReward(sb, quest);
        }

        sb.AppendLine();
        sb.AppendLine("            -- Complete and deactivate quest");
        sb.AppendLine($"            Quest:SetQuestAsCompleted(\"{quest.Name}\", true, false, false)");
        sb.AppendLine($"            Quest:DeactivateQuestLater(\"{quest.Name}\", 10)");
        sb.AppendLine("            break");
        sb.AppendLine("        end");
        sb.AppendLine("        Quest:Pause(0.5)");
        sb.AppendLine("        if not Quest:NewScriptFrame() then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateUserThread(StringBuilder sb, QuestThread thread)
    {
        sb.AppendLine($"function {thread.FunctionName}(questObject)");
        sb.AppendLine("    Quest = questObject");
        if (!string.IsNullOrWhiteSpace(thread.Description))
        {
            sb.AppendLine($"    -- {thread.Description}");
        }
        sb.AppendLine("    -- TODO: Implement thread logic");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    // GenerateCompleteQuestFunction has been removed - completion logic is now inlined
    // in MonitorQuestCompletion thread to preserve PActiveThread context

    private void GenerateContainerSpawn(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine();
        sb.AppendLine("    -- Spawn reward container");

        // Generate spawn code based on location type
        switch (container.SpawnLocation)
        {
            case ContainerSpawnLocation.NearMarker:
                sb.AppendLine($"    local marker = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine("    local containerPos");
                sb.AppendLine("    if marker ~= nil then");
                sb.AppendLine("        containerPos = marker:GetPos()");
                sb.AppendLine("    else");
                sb.AppendLine("        local hero = Quest:GetHero()");
                sb.AppendLine("        containerPos = hero:GetPos()");
                sb.AppendLine("    end");
                break;

            case ContainerSpawnLocation.NearEntity:
                sb.AppendLine($"    local entity = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine("    local containerPos");
                sb.AppendLine("    if entity ~= nil then");
                sb.AppendLine("        containerPos = entity:GetPos()");
                sb.AppendLine("    else");
                sb.AppendLine("        local hero = Quest:GetHero()");
                sb.AppendLine("        containerPos = hero:GetPos()");
                sb.AppendLine("    end");
                break;

            case ContainerSpawnLocation.FixedPosition:
                string x = container.X.ToString(CultureInfo.InvariantCulture);
                string y = container.Y.ToString(CultureInfo.InvariantCulture);
                string z = container.Z.ToString(CultureInfo.InvariantCulture);
                sb.AppendLine($"    local containerPos = {{x={x}, y={y}, z={z}}}");
                break;
        }

        sb.AppendLine($"    local container = Quest:CreateObject(\"{container.ContainerDefName}\", containerPos, \"{container.ContainerScriptName}\")");
        sb.AppendLine("    if container ~= nil then");

        // Add items to container
        foreach (string item in container.Items)
        {
            sb.AppendLine($"        Quest:AddItemToContainer(container, \"{item}\")");
        }

        // Highlight container if configured
        if (container.HighlightContainer)
        {
            sb.AppendLine("        Quest:SetThingHasInformation(container, true)");
        }

        sb.AppendLine("    end");
        sb.AppendLine("    Quest:Pause(0.1)");
        sb.AppendLine("    if not Quest:NewScriptFrame() then return end");
    }

    private void GenerateContainerReward(StringBuilder sb, QuestProject quest)
    {
        GenerateTraditionalContainerReward(sb, quest);
    }

    /// <summary>
    /// Generates traditional container-based rewards using container APIs.
    /// Only works with chest-like objects.
    /// </summary>
    private void GenerateTraditionalContainerReward(StringBuilder sb, QuestProject quest)
    {
        var container = quest.Rewards.Container!;

        sb.AppendLine();
        sb.AppendLine("            -- Container reward: Spawn and populate container");
        sb.AppendLine("            Quest:Log(\"Attempting to spawn container...\")");

        // Generate spawn position code
        GenerateContainerSpawnPosition(sb, container, "            ");

        // Spawn the container
        sb.AppendLine($"            Quest:Log(\"Creating container: {container.ContainerDefName} at position...\")");
        sb.AppendLine($"            local container = Quest:CreateObject(\"{container.ContainerDefName}\", containerPos, \"{container.ContainerScriptName}\")");
        sb.AppendLine("            Quest:Log(\"CreateObject returned: \" .. tostring(container))");
        sb.AppendLine("            if container ~= nil then");
        sb.AppendLine("                Quest:Log(\"Container spawned successfully!\")");

        // CRITICAL: Make the container targetable/interactive
        sb.AppendLine("                Quest:EntitySetTargetable(container, true)");
        sb.AppendLine("                Quest:Log(\"Container set as targetable\")");

        if (container.AutoGiveOnComplete)
        {
            // Give items directly to hero (more reliable than GiveHeroItemsFromContainer)
            foreach (string item in container.Items)
            {
                sb.AppendLine($"                Quest:GiveHeroObject(\"{item}\", 1)");
            }
        }
        else
        {
            // Manual opening mode: Entity script handles giving items when hero interacts
            // The container was spawned with a script name that has a bound entity script
            // which will detect interaction via Me:MsgIsUsedByHero() and give all items
            sb.AppendLine("                -- Container uses entity script for multi-item rewards on manual open");

            // Highlight the container for player to find
            if (container.HighlightContainer)
            {
                sb.AppendLine("                Quest:SetThingHasInformation(container, true)");
            }
        }

        sb.AppendLine("            else");
        sb.AppendLine("                Quest:Log(\"WARNING: Failed to spawn container!\")");
        sb.AppendLine("            end");
    }

    /// <summary>
    /// Generates the spawn position code for containers/objects
    /// </summary>
    private void GenerateContainerSpawnPosition(StringBuilder sb, ContainerReward container, string indent)
    {
        switch (container.SpawnLocation)
        {
            case ContainerSpawnLocation.NearMarker:
                sb.AppendLine($"{indent}local marker = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine($"{indent}local containerPos");
                sb.AppendLine($"{indent}if marker ~= nil then");
                sb.AppendLine($"{indent}    containerPos = marker:GetPos()");
                sb.AppendLine($"{indent}else");
                sb.AppendLine($"{indent}    local hero = Quest:GetHero()");
                sb.AppendLine($"{indent}    containerPos = hero:GetPos()");
                sb.AppendLine($"{indent}end");
                break;

            case ContainerSpawnLocation.NearEntity:
                sb.AppendLine($"{indent}local entity = Quest:GetThingWithScriptName(\"{container.SpawnReference}\")");
                sb.AppendLine($"{indent}local containerPos");
                sb.AppendLine($"{indent}if entity ~= nil then");
                sb.AppendLine($"{indent}    containerPos = entity:GetPos()");
                sb.AppendLine($"{indent}else");
                sb.AppendLine($"{indent}    local hero = Quest:GetHero()");
                sb.AppendLine($"{indent}    containerPos = hero:GetPos()");
                sb.AppendLine($"{indent}end");
                break;

            case ContainerSpawnLocation.FixedPosition:
                string x = container.X.ToString(CultureInfo.InvariantCulture);
                string y = container.Y.ToString(CultureInfo.InvariantCulture);
                string z = container.Z.ToString(CultureInfo.InvariantCulture);
                sb.AppendLine($"{indent}local containerPos = {{x={x}, y={y}, z={z}}}");
                break;
        }
    }

    /// <summary>
    /// Generates automatic behavior for object entities with rewards.
    /// This creates a loop that waits for the hero to interact with the object,
    /// then gives the configured rewards.
    /// </summary>
    private void GenerateObjectRewardBehavior(StringBuilder sb, QuestEntity entity)
    {
        var reward = entity.ObjectReward!;
        string stateVar = $"{entity.ScriptName}_opened";

        sb.AppendLine("    -- Auto-generated reward behavior for object");
        sb.AppendLine("    -- This object gives rewards when interacted with by the hero");
        sb.AppendLine();

        if (reward.OneTimeOnly)
        {
            sb.AppendLine($"    local alreadyOpened = Quest:GetStateBool(\"{stateVar}\")");
            sb.AppendLine("    if alreadyOpened then");
            sb.AppendLine($"        Quest:Log(\"{entity.ScriptName}: Already opened, skipping reward behavior\")");
            sb.AppendLine("        return");
            sb.AppendLine("    end");
            sb.AppendLine();
        }

        sb.AppendLine("    -- Make object interactive");
        sb.AppendLine("    Quest:EntitySetTargetable(Me, true)");
        sb.AppendLine("    Quest:SetThingHasInformation(Me, true)");
        sb.AppendLine();
        sb.AppendLine("    -- Wait for hero interaction");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Me:MsgIsUsedByHero() then");
        sb.AppendLine($"            Quest:Log(\"{entity.ScriptName}: Hero interacted with object, giving rewards\")");
        sb.AppendLine();

        // Give gold
        if (reward.Gold > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroGold({reward.Gold})");
        }

        // Give experience
        if (reward.Experience > 0)
        {
            sb.AppendLine($"            Quest:GiveHeroExperience({reward.Experience})");
        }

        // Give items
        foreach (string item in reward.Items)
        {
            sb.AppendLine($"            Quest:GiveHeroObject(\"{item}\", 1)");
        }

        // Show message
        if (reward.ShowMessage)
        {
            if (!string.IsNullOrWhiteSpace(reward.CustomMessage))
            {
                sb.AppendLine($"            Quest:ShowMessage(\"{Escape(reward.CustomMessage)}\", 3.0)");
            }
            else
            {
                // Build default message
                var messageParts = new List<string>();
                if (reward.Gold > 0) messageParts.Add($"{reward.Gold} gold");
                if (reward.Experience > 0) messageParts.Add($"{reward.Experience} XP");
                if (reward.Items.Count > 0) messageParts.Add($"{reward.Items.Count} item(s)");
                string defaultMessage = "Received: " + string.Join(", ", messageParts);
                sb.AppendLine($"            Quest:ShowMessage(\"{defaultMessage}\", 3.0)");
            }
        }

        // Mark as opened for one-time only objects
        if (reward.OneTimeOnly)
        {
            sb.AppendLine();
            sb.AppendLine($"            Quest:SetStateBool(\"{stateVar}\", true)");
        }

        // Destroy object if configured
        if (reward.DestroyAfterReward)
        {
            sb.AppendLine();
            sb.AppendLine("            -- Destroy the object after giving rewards");
            sb.AppendLine("            Quest:SetThingAsKilled(Me)");
            sb.AppendLine("            break");
        }
        else if (reward.OneTimeOnly)
        {
            sb.AppendLine();
            sb.AppendLine("            -- Remove highlight since object was already used");
            sb.AppendLine("            Quest:ClearThingHasInformation(Me)");
            sb.AppendLine("            break");
        }

        sb.AppendLine("        end");
        sb.AppendLine();
        sb.AppendLine("        if Me:IsNull() then break end");
        sb.AppendLine("        if not Quest:NewScriptFrame(Me) then break end");
        sb.AppendLine("    end");
    }

    private (int X, int Y) GetWorldMapOffset(QuestProject quest)
    {
        string primaryRegion = quest.Regions.FirstOrDefault() ?? "";
        return WorldMapCoordinateService.GetMapOffsetForQuest(primaryRegion, quest.Entities);
    }

    private string RenderStateInit(QuestState state)
    {
        string value = state.DefaultValue?.ToString() ?? GetDefaultForType(state.Type);
        
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:SetStateBool(\"{state.Name}\", {value.ToLowerInvariant()})",
            "int" => $"    Quest:SetStateInt(\"{state.Name}\", {value})",
            "float" => $"    Quest:SetStateFloat(\"{state.Name}\", {value})",
            "string" => $"    Quest:SetStateString(\"{state.Name}\", \"{value}\")",
            _ => $"    Quest:SetStateBool(\"{state.Name}\", false) -- Unknown type: {state.Type}"
        };
    }

    private string RenderStatePersist(QuestState state)
    {
        return state.Type.ToLowerInvariant() switch
        {
            "bool" => $"    Quest:PersistTransferBool(context, \"{state.Name}\")",
            "int" => $"    Quest:PersistTransferInt(context, \"{state.Name}\")",
            "float" => $"    Quest:PersistTransferFloat(context, \"{state.Name}\")",
            "string" => $"    Quest:PersistTransferString(context, \"{state.Name}\")",
            _ => $"    Quest:PersistTransferBool(context, \"{state.Name}\") -- Unknown type: {state.Type}"
        };
    }

    private string GenerateQuestLuaEntry(QuestProject quest)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    {quest.Name} = {{");
        sb.AppendLine($"        name = \"{quest.Name}\",");
        sb.AppendLine($"        file = \"{quest.Name}/{quest.Name}\",");
        sb.AppendLine($"        id = {quest.Id},");
        sb.AppendLine();
        sb.AppendLine("        entity_scripts = {");

        int entityId = quest.Id + 1;
        foreach (QuestEntity entity in quest.Entities)
        {
            sb.AppendLine($"            {{ name = \"{entity.ScriptName}\", file = \"{quest.Name}/Entities/{entity.ScriptName}\", id = {entityId} }},");
            entityId++;
        }

        // Add container entity script if needed (for manual-opening containers)
        if (NeedsContainerEntityScript(quest))
        {
            var container = quest.Rewards.Container!;
            sb.AppendLine($"            {{ name = \"{container.ContainerScriptName}\", file = \"{quest.Name}/Entities/{container.ContainerScriptName}\", id = {entityId} }},");
        }

        sb.AppendLine("        }");
        sb.Append("    },");

        return sb.ToString();
    }

    private static string GetDefaultForType(string type)
    {
        return type.ToLowerInvariant() switch
        {
            "bool" => "false",
            "int" => "0",
            "float" => "0.0",
            "string" => "",
            _ => "false"
        };
    }

    public string GenerateBehaviorCode(QuestEntity entity, string questName, int indent = 2)
    {
        if (entity.Nodes.Count == 0)
        {
            return GenerateIndent(indent) + "-- No behavior nodes defined\n";
        }

        StringBuilder sb = new StringBuilder();

        // Find all trigger nodes (entry points)
        var triggerNodes = entity.Nodes.Where(n => n.Category == "trigger").ToList();

        if (triggerNodes.Count == 0)
        {
            sb.AppendLine(GenerateIndent(indent) + "-- No trigger nodes found");
            return sb.ToString();
        }

        // Generate code for each trigger
        foreach (var trigger in triggerNodes)
        {
            sb.Append(GenerateNodeCode(trigger, entity, questName, indent));
        }

        return sb.ToString();
    }

    private static string GenerateIndent(int level)
    {
        return new string(' ', level * 4);
    }

    /// <summary>
    /// Generates Lua code for a behavior node and its children.
    /// Handles both structured nodes (triggers, conditions) and linear action sequences.
    /// </summary>
    private string GenerateNodeCode(BehaviorNode node, QuestEntity entity, string questName, int indent)
    {
        var nodeDef = NodeDefinitions.GetAllNodes().FirstOrDefault(n => n.Type == node.Type) ??
                      TryBuildVariableNodeDefinition(node, entity);
        if (nodeDef == null)
        {
            return GenerateIndent(indent) + $"-- Unknown node type: {node.Type}\n";
        }

        StringBuilder sb = new StringBuilder();

        if (ActionQueueNodeTypes.Contains(node.Type))
        {
            string queueCode = BuildActionQueueCode(node, entity);
            foreach (string line in queueCode.Split('\n'))
            {
                if (!string.IsNullOrWhiteSpace(line))
                {
                    sb.AppendLine(GenerateIndent(indent) + line);
                }
            }

            var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    sb.Append(GenerateNodeCode(childNode, entity, questName, indent));
                }
            }

            return sb.ToString();
        }

        // Check if this is a linear action (non-branching action node)
        bool isLinearAction = nodeDef.Category == "action" && !nodeDef.HasBranching;

        if (isLinearAction)
        {
            // For linear actions, emit THIS node's code at current indent,
            // then emit children at SAME indent (not nested)
            string code = ProcessNodeTemplate(nodeDef, node, entity, questName);
            
            // Remove {CHILDREN} - we handle sequencing explicitly
            code = code.Replace("{CHILDREN}", "").TrimEnd();

            // Emit this node's code lines
            foreach (string line in code.Split('\n'))
            {
                if (!string.IsNullOrWhiteSpace(line))
                {
                    sb.AppendLine(GenerateIndent(indent) + line);
                }
            }

            // Process children at SAME indent level (linear sequence, not nested)
            var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    sb.Append(GenerateNodeCode(childNode, entity, questName, indent)); // Same indent!
                }
            }
        }
        else
        {
            // For structured nodes (triggers, conditions, flow), use template substitution
            sb.Append(GenerateStructuredNode(node, nodeDef, entity, questName, indent));
        }

        return sb.ToString();
    }

    /// <summary>
    /// Processes a node's template, replacing placeholders with config values.
    /// Text and string properties are escaped to prevent Lua syntax errors.
    /// </summary>
    private string ProcessNodeTemplate(NodeDefinition nodeDef, BehaviorNode node, QuestEntity entity, string questName)
    {
        string code = nodeDef.CodeTemplate;

        code = code.Replace("{QUEST_NAME}", Escape(questName));

        // Build a lookup of property types for escaping decisions
        var propertyTypes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                propertyTypes[propDef.Name] = propDef.Type;
            }
        }

        // Apply config values from the node (with proper escaping for text/string types)
        foreach (var prop in node.Config)
        {
            string placeholder = "{" + prop.Key + "}";
            string value = prop.Value?.ToString() ?? "";

            if (TryResolveVariableReference(entity, value, out string luaName))
            {
                code = ReplacePlaceholderWithVariable(code, prop.Key, luaName);
                continue;
            }

            // Escape text and string properties to prevent Lua syntax errors from quotes/special chars
            if (propertyTypes.TryGetValue(prop.Key, out string? propType) &&
                (propType == "text" || propType == "string"))
            {
                value = Escape(value);
            }

            code = code.Replace(placeholder, value);
        }

        // Apply default values for missing properties (with proper escaping)
        if (nodeDef.Properties != null)
        {
            foreach (var propDef in nodeDef.Properties)
            {
                string placeholder = "{" + propDef.Name + "}";
                if (code.Contains(placeholder))
                {
                    string defaultValue = propDef.DefaultValue?.ToString() ?? "";

                    if (TryResolveVariableReference(entity, defaultValue, out string luaName))
                    {
                        code = ReplacePlaceholderWithVariable(code, propDef.Name, luaName);
                        continue;
                    }

                    // Escape text and string default values
                    if (propDef.Type == "text" || propDef.Type == "string")
                    {
                        defaultValue = Escape(defaultValue);
                    }

                    code = code.Replace(placeholder, defaultValue);
                }
            }
        }

        return code;
    }

    /// <summary>
    /// Generates code for structured nodes (triggers, conditions, flow control).
    /// Children are indented inside the control structure.
    /// </summary>
    private string GenerateStructuredNode(BehaviorNode node, NodeDefinition nodeDef, QuestEntity entity, string questName, int indent)
    {
        StringBuilder sb = new StringBuilder();
        string code = ProcessNodeTemplate(nodeDef, node, entity, questName);

        // Handle children (connected nodes)
        var connections = entity.Connections.Where(c => c.FromNodeId == node.Id).ToList();
        
        if (nodeDef.HasBranching)
        {
            // Branching nodes (if/else) - children go into specific branches at indent+1
            var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
            var branchCode = new Dictionary<string, StringBuilder>();

            foreach (var label in branchLabels)
            {
                branchCode[label] = new StringBuilder();
            }

            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null && !string.IsNullOrEmpty(conn.FromPort))
                {
                    string childCode = GenerateNodeCode(childNode, entity, questName, indent + 1);
                    if (branchCode.ContainsKey(conn.FromPort))
                    {
                        branchCode[conn.FromPort].Append(childCode);
                    }
                }
            }

            foreach (var label in branchLabels)
            {
                string placeholder = "{" + label + "}";
                string placeholderUpper = "{" + label.ToUpper() + "}";
                string branchContent = branchCode[label].Length > 0
                    ? branchCode[label].ToString().TrimEnd('\n')
                    : GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";

                code = code.Replace(placeholder, branchContent);
                code = code.Replace(placeholderUpper, branchContent);
            }
        }
        else if (connections.Count > 0)
        {
            // Non-branching structured node (trigger) - children go inside at indent+1
            StringBuilder childrenCode = new StringBuilder();
            foreach (var conn in connections)
            {
                var childNode = entity.Nodes.FirstOrDefault(n => n.Id == conn.ToNodeId);
                if (childNode != null)
                {
                    childrenCode.Append(GenerateNodeCode(childNode, entity, questName, indent + 1));
                }
            }
            code = code.Replace("{CHILDREN}", childrenCode.ToString().TrimEnd('\n'));
        }
        else
        {
            // No connections - clear placeholders
            code = code.Replace("{CHILDREN}", "");
            
            if (nodeDef.HasBranching)
            {
                var branchLabels = nodeDef.BranchLabels ?? new List<string> { "True", "False" };
                foreach (var label in branchLabels)
                {
                    string placeholder = "{" + label + "}";
                    string placeholderUpper = "{" + label.ToUpper() + "}";
                    string comment = GenerateIndent(indent + 1) + $"-- {label.ToLower()} branch";
                    code = code.Replace(placeholder, comment);
                    code = code.Replace(placeholderUpper, comment);
                }
            }
        }

        // Emit code with proper indentation
        // Lines that are already indented (from child substitution) are emitted as-is
        foreach (string line in code.Split('\n'))
        {
            if (string.IsNullOrWhiteSpace(line))
            {
                continue;
            }
            
            // Check if line is already indented (from child code substitution)
            bool alreadyIndented = line.Length > 0 && (line[0] == ' ' || line[0] == '\t');
            
            if (alreadyIndented)
            {
                sb.AppendLine(line);
            }
            else
            {
                sb.AppendLine(GenerateIndent(indent) + line);
            }
        }

        return sb.ToString();
    }

    private static string ReplacePlaceholderWithVariable(string code, string propName, string luaName)
    {
        string quotedPlaceholder = $"\"{{{propName}}}\"";
        if (code.Contains(quotedPlaceholder))
        {
            code = code.Replace(quotedPlaceholder, luaName);
        }

        string placeholder = "{" + propName + "}";
        return code.Replace(placeholder, luaName);
    }

    private bool TryResolveVariableReference(QuestEntity entity, string value, out string luaName)
    {
        luaName = string.Empty;
        if (string.IsNullOrWhiteSpace(value) || value[0] != '$')
        {
            return false;
        }

        bool isExternal = value.StartsWith("$@", StringComparison.Ordinal);
        string variableName = value.Substring(isExternal ? 2 : 1).Trim();
        if (string.IsNullOrWhiteSpace(variableName))
        {
            return false;
        }

        if (isExternal)
        {
            luaName = BuildExposedVariableGetExpression(variableName, TryGetExposedVariableType(variableName));
            return true;
        }

        if (entity.Variables == null)
        {
            return false;
        }

        var variable = entity.Variables.FirstOrDefault(v =>
            v.Name.Equals(variableName, StringComparison.OrdinalIgnoreCase));

        if (variable == null)
        {
            return false;
        }

        if (variable.IsExposed)
        {
            string key = BuildExposedVariableKey(entity.ScriptName, variableName);
            luaName = BuildExposedVariableGetExpression(key, variable.Type);
            return true;
        }

        luaName = BuildLuaVariableName(variableName);
        return true;
    }

    private Dictionary<string, string> BuildExposedVariableTypeMap(QuestProject quest)
    {
        var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        foreach (var entity in quest.Entities)
        {
            foreach (var variable in entity.Variables.Where(v => v.IsExposed))
            {
                if (string.IsNullOrWhiteSpace(entity.ScriptName) || string.IsNullOrWhiteSpace(variable.Name))
                {
                    continue;
                }

                string key = BuildExposedVariableKey(entity.ScriptName, variable.Name);
                map[key] = variable.Type;
            }
        }

        return map;
    }

    private string? TryGetExposedVariableType(string key)
    {
        if (exposedVariableTypes.TryGetValue(key, out string? type))
        {
            return type;
        }

        return null;
    }

    private static string BuildExposedVariableKey(string entityScriptName, string variableName)
    {
        return $"{entityScriptName}.{variableName}";
    }

    private static string BuildExposedVariableGetExpression(string key, string? type)
    {
        return (type ?? "String") switch
        {
            "Boolean" => $"Quest:GetStateBool(\"{Escape(key)}\")",
            "Integer" => $"Quest:GetStateInt(\"{Escape(key)}\")",
            "Float" => $"tonumber(Quest:GetStateString(\"{Escape(key)}\"))",
            "Object" => $"Quest:GetStateString(\"{Escape(key)}\")",
            _ => $"Quest:GetStateString(\"{Escape(key)}\")"
        };
    }

    private static string BuildExposedVariableSetExpression(string key, string? type, string valueExpression)
    {
        return (type ?? "String") switch
        {
            "Boolean" => $"Quest:SetStateBool(\"{Escape(key)}\", {valueExpression})",
            "Integer" => $"Quest:SetStateInt(\"{Escape(key)}\", {valueExpression})",
            "Float" => $"Quest:SetStateString(\"{Escape(key)}\", tostring({valueExpression}))",
            "Object" => $"Quest:SetStateString(\"{Escape(key)}\", tostring({valueExpression}))",
            _ => $"Quest:SetStateString(\"{Escape(key)}\", tostring({valueExpression}))"
        };
    }

    private static string MapVariableTypeToNodeType(string variableType)
    {
        return variableType switch
        {
            "Boolean" => "bool",
            "Integer" => "int",
            "Float" => "float",
            "String" => "string",
            "Object" => "object",
            _ => "string"
        };
    }

    private NodeDefinition? TryBuildVariableNodeDefinition(BehaviorNode node, QuestEntity entity)
    {
        const string getPrefix = "var_get_";
        const string setPrefix = "var_set_";
        const string getExternalPrefix = "var_get_ext";
        const string setExternalPrefix = "var_set_ext";

        bool isExternal = node.Type.StartsWith(getExternalPrefix, StringComparison.OrdinalIgnoreCase) ||
                          node.Type.StartsWith(setExternalPrefix, StringComparison.OrdinalIgnoreCase) ||
                          node.Config.ContainsKey("extEntity");

        if (!isExternal &&
            !node.Type.StartsWith(getPrefix, StringComparison.OrdinalIgnoreCase) &&
            !node.Type.StartsWith(setPrefix, StringComparison.OrdinalIgnoreCase))
        {
            return null;
        }

        if (isExternal)
        {
            string extEntity = node.Config.TryGetValue("extEntity", out var entValue)
                ? entValue?.ToString() ?? string.Empty
                : string.Empty;
            string extVariable = node.Config.TryGetValue("extVariable", out var varValue)
                ? varValue?.ToString() ?? string.Empty
                : string.Empty;
            string extType = node.Config.TryGetValue("extType", out var typeValue)
                ? typeValue?.ToString() ?? "String"
                : "String";

            string key = BuildExposedVariableKey(extEntity, extVariable);
            string externalNodeType = MapVariableTypeToNodeType(extType);
            bool isSetNode = node.Type.StartsWith(setExternalPrefix, StringComparison.OrdinalIgnoreCase);

            if (!isSetNode)
            {
                return new NodeDefinition
                {
                    Type = node.Type,
                    Label = $"Get {key}",
                    Category = "variable",
                    Icon = "?",
                    IsAdvanced = false,
                    Description = $"Gets exposed variable '{key}'",
                    ValueType = extType,
                    Properties = new List<NodeProperty>(),
                    CodeTemplate = $"local var_value = {BuildExposedVariableGetExpression(key, extType)}\n{{CHILDREN}}"
                };
            }

            bool externalIsString = externalNodeType == "string";
            string externalValueTemplate = externalIsString ? "\"{value}\"" : "{value}";
            string setExpression = BuildExposedVariableSetExpression(key, extType, externalValueTemplate);

            return new NodeDefinition
            {
                Type = node.Type,
                Label = $"Set {key}",
                Category = "variable",
                Icon = "?",
                IsAdvanced = false,
                Description = $"Sets exposed variable '{key}'",
                ValueType = extType,
                Properties = new List<NodeProperty>
                {
                    new() { Name = "value", Type = externalNodeType, Label = "Value", DefaultValue = string.Empty }
                },
                CodeTemplate = $"{setExpression}\n{{CHILDREN}}"
            };
        }

        string variableName = node.Type.StartsWith(getPrefix, StringComparison.OrdinalIgnoreCase)
            ? node.Type.Substring(getPrefix.Length)
            : node.Type.Substring(setPrefix.Length);

        var variable = entity.Variables.FirstOrDefault(v =>
            v.Name.Equals(variableName, StringComparison.OrdinalIgnoreCase));

        if (variable == null)
        {
            return null;
        }

        string variableType = variable.Type ?? "String";
        string luaName = BuildLuaVariableName(variableName);
        string nodeType = MapVariableTypeToNodeType(variableType);

        if (node.Type.StartsWith(getPrefix, StringComparison.OrdinalIgnoreCase))
        {
            string getExpression = variable.IsExposed
                ? BuildExposedVariableGetExpression(BuildExposedVariableKey(entity.ScriptName, variableName), variableType)
                : luaName;
            return new NodeDefinition
            {
                Type = node.Type,
                Label = $"Get {variableName}",
                Category = "variable",
                Icon = "?",
                IsAdvanced = false,
                Description = $"Gets the value of variable '{variableName}'",
                ValueType = variableType,
                Properties = new List<NodeProperty>(),
                CodeTemplate = $"local {luaName}_value = {getExpression}\n{{CHILDREN}}"
            };
        }

        bool isString = nodeType == "string";
        string valueTemplate = isString ? "\"{value}\"" : "{value}";
        string setTemplate = variable.IsExposed
            ? BuildExposedVariableSetExpression(BuildExposedVariableKey(entity.ScriptName, variableName), variableType, valueTemplate)
            : $"{luaName} = {valueTemplate}";

        return new NodeDefinition
        {
            Type = node.Type,
            Label = $"Set {variableName}",
            Category = "variable",
            Icon = "?",
            IsAdvanced = false,
            Description = $"Sets the value of variable '{variableName}'",
            ValueType = variableType,
            Properties = new List<NodeProperty>
            {
                new() { Name = "value", Type = nodeType, Label = "Value", DefaultValue = variable.DefaultValue ?? string.Empty }
            },
            CodeTemplate = $"{setTemplate}\n{{CHILDREN}}"
        };
    }

    private static string BuildLuaVariableName(string variableName)
    {
        if (string.IsNullOrWhiteSpace(variableName))
        {
            return "var_unnamed";
        }

        var chars = variableName.Select(c =>
        {
            if (c <= 127 && (char.IsLetterOrDigit(c) || c == '_'))
            {
                return c;
            }

            return '_';
        }).ToArray();

        string normalized = new string(chars);
        if (char.IsDigit(normalized[0]))
        {
            normalized = "_" + normalized;
        }

        return "var_" + normalized;
    }

    private static bool NeedsActionQueue(QuestProject quest)
    {
        return quest.Entities.Any(entity => entity.Nodes.Any(node => ActionQueueNodeTypes.Contains(node.Type)));
    }

    private string BuildActionQueueCode(BehaviorNode node, QuestEntity entity)
    {
        string actionType = node.Type switch
        {
            "highlightQuestTarget" => "Highlight",
            "clearQuestTargetHighlight" => "ClearHighlight",
            "showMinimapMarker" => "ShowMarker",
            "hideMinimapMarker" => "HideMarker",
            "highlightQuestTargetByName" => "Highlight",
            "clearQuestTargetHighlightByName" => "ClearHighlight",
            "showMinimapMarkerByName" => "ShowMarker",
            "hideMinimapMarkerByName" => "HideMarker",
            _ => "Highlight"
        };

        string targetName = entity.ScriptName;
        string markerName = entity.ScriptName;

        if (node.Config.TryGetValue("targetScriptName", out var targetValue) && targetValue != null)
        {
            targetName = targetValue.ToString() ?? targetName;
            markerName = targetName;
        }

        if (node.Config.TryGetValue("markerName", out var markerValue) && markerValue != null)
        {
            string markerText = markerValue.ToString() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(markerText))
            {
                markerName = markerText;
            }
        }

        targetName = Escape(targetName);
        markerName = Escape(markerName);

        return $"local actionId = Quest:GetStateInt(\"FQT_ActionCounter\")\n" +
               "if actionId == nil then actionId = 0 end\n" +
               "actionId = actionId + 1\n" +
               "Quest:SetStateInt(\"FQT_ActionCounter\", actionId)\n" +
               $"Quest:SetStateString(\"FQT_Action_\" .. tostring(actionId), \"{actionType}|{targetName}|{markerName}\")";
    }

    private void GenerateQuestActionQueueHelper(StringBuilder sb)
    {
        sb.AppendLine("function ProcessQuestActionQueueOnce()");
        sb.AppendLine("    local processed = Quest:GetStateInt(\"FQT_ActionProcessed\")");
        sb.AppendLine("    if processed == nil then processed = 0 end");
        sb.AppendLine("    local current = Quest:GetStateInt(\"FQT_ActionCounter\")");
        sb.AppendLine("    if current == nil then current = 0 end");
        sb.AppendLine("    while processed < current do");
        sb.AppendLine("        processed = processed + 1");
        sb.AppendLine("        local action = Quest:GetStateString(\"FQT_Action_\" .. tostring(processed))");
        sb.AppendLine("        if action ~= nil and action ~= \"\" then");
        sb.AppendLine("            local actionType, targetName, markerName = string.match(action, \"([^|]+)|([^|]+)|?(.*)\")");
        sb.AppendLine("            if actionType ~= nil and targetName ~= nil then");
        sb.AppendLine("                if markerName == nil or markerName == \"\" then");
        sb.AppendLine("                    markerName = targetName");
        sb.AppendLine("                end");
        sb.AppendLine("                local target = Quest:GetThingWithScriptName(targetName)");
        sb.AppendLine("                if target ~= nil then");
        sb.AppendLine("                    if actionType == \"Highlight\" then");
        sb.AppendLine("                        Quest:SetThingHasInformation(target, true)");
        sb.AppendLine("                    elseif actionType == \"ClearHighlight\" then");
        sb.AppendLine("                        Quest:ClearThingHasInformation(target)");
        sb.AppendLine("                    elseif actionType == \"ShowMarker\" then");
        sb.AppendLine("                        Quest:MiniMapAddMarker(target, markerName)");
        sb.AppendLine("                    elseif actionType == \"HideMarker\" then");
        sb.AppendLine("                        Quest:MiniMapRemoveMarker(target)");
        sb.AppendLine("                    end");
        sb.AppendLine("                end");
        sb.AppendLine("            end");
        sb.AppendLine("            Quest:SetStateString(\"FQT_Action_\" .. tostring(processed), \"\")");
        sb.AppendLine("        end");
        sb.AppendLine("    end");
        sb.AppendLine("    Quest:SetStateInt(\"FQT_ActionProcessed\", processed)");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private void GenerateQuestActionQueueThread(StringBuilder sb)
    {
        sb.AppendLine("function ProcessQuestActions(questObject)");
        sb.AppendLine("    Quest = questObject");
        sb.AppendLine("    while true do");
        sb.AppendLine("        if Quest:GetStateBool(\"FQT_StopActions\") then break end");
        sb.AppendLine("        ProcessQuestActionQueueOnce()");
        sb.AppendLine("        Quest:Pause(0.1)");
        sb.AppendLine("        if not Quest:NewScriptFrame() then break end");
        sb.AppendLine("    end");
        sb.AppendLine("end");
        sb.AppendLine();
    }

    private static string Escape(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;

        return text
            .Replace("\\", "\\\\")  // Must be first to avoid double-escaping
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t")
            .Replace("\0", "");     // Remove null characters
    }

    private static string FormatMoralityValue(float value)
    {
        return value.ToString(CultureInfo.InvariantCulture);
    }
}
